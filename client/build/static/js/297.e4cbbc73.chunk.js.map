{"version":3,"file":"static/js/297.e4cbbc73.chunk.js","mappings":"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","sources":["../../../../git/millegrilles.reactjs/src/hachage.js","../../../../git/millegrilles.reactjs/src/chiffrage.ciphers.js","../../../../git/millegrilles.reactjs/src/chiffrageClient.js","../../../../git/millegrilles.reactjs/src/x509Client.js","../../../../git/millegrilles.reactjs/src/connexionClient.js","workers/connexion.worker.js","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/make namespace object","../webpack/runtime/node module decorator","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["import {\n    hacher, verifierHachage, \n    Hacheur, VerificateurHachage, \n    calculerDigest,\n    hacherCertificat, comparerArraybuffers,\n    setHacheurs,\n} from '@dugrema/millegrilles.utiljs/src/hachage'\nimport { createSHA256, createSHA512, createBLAKE2b, createBLAKE2s } from 'hash-wasm'\n\n// Injecte les methodes de hachage natives avec setHacheurs pour la librairie utiljs\n\nconst constructeur = async methode => {\n    const hacheur = await methode()\n    return {\n        update: buffer => hacheur.update(buffer),\n        finalize: () => hacheur.digest('binary'),\n        digest: async buffer => { await hacheur.update(buffer); return await hacheur.digest('binary') }\n    }\n}\n\n// Utilise subtle pour digest() one shot et WASM pour blocks avec update/finalize\n// const constructeurSubtle = async (methode, algo) => {\n//     console.debug(\"Constructeur subtle methode %O, algo %O\", methode, algo)\n//     const hacheur = await methode()\n//     console.debug(\"window %O, self %O\", window, self)\n//     let refHandle = window || self\n//     return {\n//         update: buffer => hacheur.update(buffer),\n//         finalize: () => hacheur.digest('binary'),\n//         digest: async buffer => refHandle.crypto.subtle.digest(algo, buffer)\n//     }\n// }\n\nconst hacheurs = {\n    // hash-wasm\n    'sha256': () => constructeur(createSHA256),\n    'sha2-256': () => constructeur(createSHA256),\n    'sha512': () => constructeur(createSHA512),\n    'sha2-512': () => constructeur(createSHA512),\n    'blake2s256': () => constructeur(createBLAKE2s),\n    'blake2s-256': () => constructeur(createBLAKE2s),\n    'blake2b512': () => constructeur(createBLAKE2b),\n    'blake2b-512': () => constructeur(createBLAKE2b),\n}\n\n// console.debug(\"Set hacheurs : %O\", hacheurs)\nsetHacheurs(hacheurs)\n\n// export default {\n//     hacher, verifierHachage, \n//     Hacheur, VerificateurHachage, \n//     calculerDigest,\n//     hacherCertificat, comparerArraybuffers,\n//     setHacheurs, \n//     hacheurs,\n// }\n\nexport { \n    hacher, verifierHachage, \n    Hacheur, VerificateurHachage, \n    calculerDigest,\n    hacherCertificat, comparerArraybuffers,\n    setHacheurs, \n    hacheurs,\n}","import { setCiphers } from '@dugrema/millegrilles.utiljs/src/chiffrage.ciphers'\nimport { hacher, Hacheur } from './hachage'\nimport { base64 } from 'multiformats/bases/base64'\nimport _sodium from 'libsodium-wrappers'\nimport { getRandom } from '@dugrema/millegrilles.utiljs/src/random'\n\n// S'assurer de charger les methodes de hachage\n\nconst OVERHEAD_MESSAGE = 17,\n      DECIPHER_MESSAGE_SIZE = 64 * 1024,\n      MESSAGE_SIZE = DECIPHER_MESSAGE_SIZE - OVERHEAD_MESSAGE\n\n// ----- Chacha20Poly1305 (legacy mgs3, decrypt seul) -----\n\nexport async function encryptChacha20Poly1305(data, opts) {\n    opts = opts || {}\n    let {key, nonce} = opts\n    if(key) {\n        if(typeof(key)==='string') key = base64.decode(key)\n    } else {\n        key = getRandom(32)\n    }\n    if(nonce) {\n        if(typeof(nonce)==='string') nonce = base64.decode(nonce)\n    } else {\n        nonce = getRandom(12)\n    }\n\n    await _sodium.ready\n    const sodium = _sodium\n    try {\n        var {ciphertext, mac: tag} = sodium.crypto_aead_chacha20poly1305_ietf_encrypt_detached(data, null, null, nonce, key)\n    } catch(err) {\n        throw new CipherError(''+err)\n    }\n\n    // Hacher contenu chiffre\n    const hachage = await hacher(ciphertext, opts)\n    const tagStr = base64.encode(tag)\n    const nonceStr = base64.encode(nonce)\n\n    return {ciphertext, key, nonce: nonceStr, tag: tagStr, rawTag: tag, hachage, format: 'mgs3'}\n}\n\nexport async function decryptChacha20Poly1305(key, nonce, data, tag) {\n    if(typeof(key)==='string') key = base64.decode(key)\n    if(typeof(tag)==='string') tag = base64.decode(tag)\n    if(typeof(nonce)==='string') nonce = base64.decode(nonce)\n\n    // console.debug(\"Params: key: %O, nonce : %O, data: %O, tag: %O\", key, nonce, data, tag)\n\n    key = Uint8Array.from(key)\n    nonce = Uint8Array.from(nonce)\n    tag = Uint8Array.from(tag)\n    data = Uint8Array.from(data)\n\n    // Preparer libsodium (WASM)\n    await _sodium.ready\n    const sodium = _sodium\n    \n    try {\n        return sodium.crypto_aead_chacha20poly1305_ietf_decrypt_detached(null, data, tag, null, nonce, key)\n    } catch(err) {\n        throw new DecipherError(''+err)\n    }\n}\n\n// ----- Fin Chacha20Poly1305 (legacy mgs3, decrypt seul) -----\n\n// ----- Stream XChacha20 Poly1305 -----\n\nexport async function creerStreamCipherXChacha20Poly1305(opts) {\n    opts = opts || {}\n    const digestAlgo = opts.digestAlgo || 'blake2b-512'\n    const messageBuffer = new Uint8Array(MESSAGE_SIZE)\n    let positionBuffer = 0,\n        tailleOutput = 0\n\n    let { key } = opts\n    if(key) {\n        if(typeof(key) === 'string') key = base64.decode(key)\n    } else {\n        key = getRandom(32)\n    }\n\n    // Preparer libsodium, hachage (WASM)\n    const hacheur = new Hacheur({hashingCode: digestAlgo})\n    await hacheur.ready\n    await _sodium.ready\n    const sodium = _sodium\n\n    // Preparer cipher\n    const res = sodium.crypto_secretstream_xchacha20poly1305_init_push(key)\n    const state_out = res.state\n    const header = base64.encode(new Uint8Array(res.header))\n    \n    let hachage = null, etatFinal = null\n    return {\n        update: async data => {\n            data = Uint8Array.from(data)\n            let ciphertext = null\n\n            // Chiffrer tant qu'on peut remplir le buffer\n            while (positionBuffer + data.length >= MESSAGE_SIZE) {\n                // Slice data\n                let endPos = MESSAGE_SIZE - positionBuffer\n                messageBuffer.set(data.slice(0, endPos), positionBuffer)\n                data = data.slice(endPos)\n\n                // Chiffrer\n                let ciphertextMessage = sodium.crypto_secretstream_xchacha20poly1305_push(\n                    state_out, messageBuffer, null, sodium.crypto_secretstream_xchacha20poly1305_TAG_MESSAGE)\n                if(ciphertextMessage === false) throw new CipherError('Erreur encodage')\n                if(!ciphertext) ciphertext = ciphertextMessage\n                else ciphertext = new Uint8Array([...ciphertext, ...ciphertextMessage])\n\n                positionBuffer = 0  // Reset position\n            }\n\n            // Inserer data restant dans le buffer\n            if(positionBuffer + data.length <= MESSAGE_SIZE) {\n                messageBuffer.set(data, positionBuffer)\n                positionBuffer += data.length\n            }\n            \n            if(ciphertext) {\n                await hacheur.update(ciphertext)\n                tailleOutput += ciphertext.length\n            }\n\n            return ciphertext\n        },\n        finalize: async () => {\n            let ciphertextMessage = sodium.crypto_secretstream_xchacha20poly1305_push(\n                state_out, messageBuffer.slice(0,positionBuffer), null, sodium.crypto_secretstream_xchacha20poly1305_TAG_FINAL)\n            if(ciphertextMessage === false) throw new CipherError('Erreur encodage')\n            \n            await hacheur.update(ciphertextMessage)\n            tailleOutput += ciphertextMessage.length\n            hachage = await hacheur.finalize()\n\n            etatFinal = {key, header, hachage, taille: tailleOutput, format: 'mgs4'}\n            return {...etatFinal, ciphertext: ciphertextMessage}\n        },\n        header: () => header,\n        hachage: () => hachage,\n        key: () => key,\n        format: () => 'mgs4',\n        etatFinal: () => etatFinal,\n    }\n}\n\nexport async function creerStreamDecipherXChacha20Poly1305(key, header) {\n    const messageBuffer = new Uint8Array(DECIPHER_MESSAGE_SIZE)\n    let positionBuffer = 0,\n        tailleOutput = 0\n\n    if(typeof(key)==='string') key = base64.decode(key)\n    if(typeof(header)==='string') header = base64.decode(header)\n\n    // Preparer libsodium (WASM)\n    await _sodium.ready\n    const sodium = _sodium\n\n    // Preparer decipher\n    const state_in = sodium.crypto_secretstream_xchacha20poly1305_init_pull(header, key)\n\n    return {\n        update: async data => {\n            data = Uint8Array.from(data)\n            let message = null\n            \n            // Creer un buffer d'output qui permet de recevoir jusqu'a un block de plus que l'input\n            const output = new Uint8Array(data.length + DECIPHER_MESSAGE_SIZE)\n            let positionOuputMessage = 0\n\n            // Chiffrer tant qu'on peut remplir le buffer\n            while (positionBuffer + data.length >= DECIPHER_MESSAGE_SIZE) {\n                // Slice data\n                let endPos = DECIPHER_MESSAGE_SIZE - positionBuffer\n                messageBuffer.set(data.slice(0, endPos), positionBuffer)\n                data = data.slice(endPos)\n\n                // Dechiffrer\n                const resultatDechiffrage = sodium.crypto_secretstream_xchacha20poly1305_pull(state_in, messageBuffer)\n                if(resultatDechiffrage === false) throw new DecipherError('Erreur dechiffrage')\n\n                // if(!message) message = resultatDechiffrage.message\n                // else message = new Uint8Array([...message, ...resultatDechiffrage.message])\n                output.set(resultatDechiffrage.message, positionOuputMessage)\n                positionOuputMessage += resultatDechiffrage.message.length\n\n                positionBuffer = 0  // Reset position\n            }\n\n            // Inserer data restant dans le buffer\n            if(positionBuffer + data.length <= DECIPHER_MESSAGE_SIZE) {\n                messageBuffer.set(data, positionBuffer)\n                positionBuffer += data.length\n            }\n            \n            tailleOutput += positionOuputMessage\n\n            return output.slice(0, positionOuputMessage)\n        },\n        finalize: async () => {\n            let decipheredMessage\n            if(positionBuffer) {\n                const resultat = sodium.crypto_secretstream_xchacha20poly1305_pull(state_in, messageBuffer.slice(0,positionBuffer))\n                if(resultat === false) throw new DecipherError('crypto_secretstream_xchacha20poly1305_pull Erreur dechiffrage')\n                const {message} = resultat\n                decipheredMessage = message\n                tailleOutput += decipheredMessage.length\n            }\n            return {taille: tailleOutput, message: decipheredMessage}\n        }\n    }\n}\n\n/**\n * One pass encrypt ChaCha20Poly1305.\n * @param {*} key \n * @param {*} nonce \n * @param {*} data \n * @param {*} opts \n */\nexport async function encryptStreamXChacha20Poly1305(data, opts) {\n    const cipher = await creerStreamCipherXChacha20Poly1305(opts)\n\n    // Creer buffer pour resultat\n    const tailleBuffer = (Math.ceil(data.length / MESSAGE_SIZE) + 1) * DECIPHER_MESSAGE_SIZE\n    const buffer = new Uint8Array(tailleBuffer)\n    let positionLecture = 0, positionEcriture = 0\n\n    while(positionLecture < data.length) {\n        const tailleLecture = Math.min(data.length - positionLecture, MESSAGE_SIZE)\n        const dataSlice = data.slice(positionLecture, positionLecture+tailleLecture)\n        const output = await cipher.update(dataSlice)\n        if(output) {\n            buffer.set(output, positionEcriture)\n            positionEcriture += output.length\n        }\n\n        positionLecture += tailleLecture\n    }\n    let {ciphertext, header, hachage, key, format} = await cipher.finalize()\n\n    if(ciphertext) {\n        // Concatener\n        buffer.set(ciphertext, positionEcriture)\n        positionEcriture += ciphertext.length\n    }\n\n    return {key, ciphertext: buffer.slice(0, positionEcriture), header, hachage, format}\n}\n\n/**\n * One pass decrypt stream XChaCha20Poly1305.\n * @param {*} key \n * @param {*} nonce \n * @param {*} data \n * @param {*} tag \n * @param {*} opts \n */\nexport async function decryptStreamXChacha20Poly1305(key, header, ciphertext) {\n    const decipher = await creerStreamDecipherXChacha20Poly1305(key, header)\n\n    // Creer buffer pour resultat\n    const tailleBuffer = Math.ceil(ciphertext.length / DECIPHER_MESSAGE_SIZE) * MESSAGE_SIZE\n    const buffer = new Uint8Array(tailleBuffer)\n    let positionLecture = 0, positionEcriture = 0\n\n    while(positionLecture < ciphertext.length) {\n        const tailleLecture = Math.min(ciphertext.length - positionLecture, DECIPHER_MESSAGE_SIZE)\n        const cipherSlice = ciphertext.slice(positionLecture, positionLecture+tailleLecture)\n        const output = await decipher.update(cipherSlice)\n        if(output) {\n            buffer.set(output, positionEcriture)\n            positionEcriture += output.length\n        }\n\n        positionLecture += tailleLecture\n    }\n    let {message} = await decipher.finalize()\n\n    if(message) {\n        // Concatener\n        buffer.set(message, positionEcriture)\n        positionEcriture += message.length\n    }\n\n    return buffer.slice(0, positionEcriture)\n}\n\n// ----- Fin stream XChacha20 Poly1305 -----\n\nasync function creerReadableStream() {\n\n    let readableStream = null\n    const controller = await new Promise(resolve => {\n        readableStream = new ReadableStream({\n            start: controller => {\n                resolve(controller)\n            },\n        })\n    })\n\n    return {controller, stream: readableStream}\n}\n\nexport class CipherError extends Error {}\n\nexport class DecipherError extends Error {}\n\nexport class NonSupporteError extends Error {}\n\n\n// Signatures\n// - encrypt : (data, opts)\n// - decrypt : (key, ciphertext, opts)\n// - getCipher : (opts)\n// - getDecipher : (key, opts)\n// Selon l'algorithme, opts peut etre :\n// - chiffrage { key, nonce } selon le cas\n// - dechiffrage { nonce, tag, header } selon le cas\n\nconst streamXchacha20poly1305Algorithm = {\n    encrypt: encryptStreamXChacha20Poly1305,\n    decrypt: (key, data, opts) => decryptStreamXChacha20Poly1305(key, opts.header, data),\n    getCipher: creerStreamCipherXChacha20Poly1305,\n    getDecipher: (key, opts) => creerStreamDecipherXChacha20Poly1305(key, opts.header),\n    messageSize: MESSAGE_SIZE,\n    stream: true,\n}\n\nconst chacha20poly1305Algorithm = {\n    encrypt: encryptChacha20Poly1305,\n    decrypt: (key, data, opts) => decryptChacha20Poly1305(key, opts.nonce||opts.iv, data, opts.tag),\n    getCipher: nonSupporte,\n    getDecipher: nonSupporte,\n    stream: false,\n}\n\nconst dummy = {\n    encrypt: (data, opts) => { return data },\n    decrypt: (key, data, opts) => { return data },\n    getCipher: () => {\n        return {\n            update: data => data,\n            finalize: () => { return {} },\n            header: () => header,\n            hachage: () => hachage,\n            key: () => key,\n            format: () => 'dummy',\n            etatFinal: () => etatFinal,\n        }\n    },\n    getDecipher: () => {\n        const messageBuffer = new Uint8Array(DECIPHER_MESSAGE_SIZE)\n        let positionBuffer = 0,\n            tailleOutput = 0\n\n        return {\n            update: data => {\n                data = Uint8Array.from(data)\n\n                // Creer un buffer d'output qui permet de recevoir jusqu'a un block de plus que l'input\n                const output = new Uint8Array(data.length + DECIPHER_MESSAGE_SIZE)\n                let positionOuputMessage = 0\n    \n                // Chiffrer tant qu'on peut remplir le buffer\n                while (positionBuffer + data.length >= DECIPHER_MESSAGE_SIZE) {\n                    // Slice data\n                    let endPos = DECIPHER_MESSAGE_SIZE - positionBuffer\n                    messageBuffer.set(data.slice(0, endPos), positionBuffer)\n                    data = data.slice(endPos)\n    \n                    // Dechiffrer\n                    // const resultatDechiffrage = sodium.crypto_secretstream_xchacha20poly1305_pull(state_in, messageBuffer)\n                    // if(resultatDechiffrage === false) throw new DecipherError('Erreur dechiffrage')\n                    // if(!message) message = data\n                    // else message = new Uint8Array([...message, ...data])\n                    output.set(messageBuffer, positionOuputMessage)\n                    positionOuputMessage += messageBuffer.length\n    \n                    positionBuffer = 0  // Reset position\n                }\n    \n                // Inserer data restant dans le buffer\n                if(positionBuffer + data.length <= DECIPHER_MESSAGE_SIZE) {\n                    messageBuffer.set(data, positionBuffer)\n                    positionBuffer += data.length\n                }\n                \n                // if(message) {\n                //     tailleOutput += message.length\n                // }\n                if(positionOuputMessage) {\n                    tailleOutput += positionOuputMessage\n                }\n    \n                return output.slice(0, positionOuputMessage)\n            },\n            finalize: () => { return {} },\n        }\n    },\n    messageSize: MESSAGE_SIZE,\n    stream: true,\n}\n\nfunction nonSupporte() {\n    throw new NonSupporteError(\"cipher/decipher non supporte\")\n}\n\nconst ciphers = {\n    'chacha20-poly1305': chacha20poly1305Algorithm,\n    'stream-xchacha20poly1305': streamXchacha20poly1305Algorithm,\n    'mgs3': chacha20poly1305Algorithm,\n    'mgs4': streamXchacha20poly1305Algorithm,\n    'dummy': dummy,\n}\n\nsetCiphers(ciphers)\n","import { base64 } from 'multiformats/bases/base64'\nimport { pki as forgePki, ed25519 } from '@dugrema/node-forge'\n\nimport { CertificateStore, extraireExtensionsMillegrille } from '@dugrema/millegrilles.utiljs/src/forgecommon'\nimport { FormatteurMessageEd25519, SignateurMessageEd25519 } from '@dugrema/millegrilles.utiljs/src/formatteurMessage'\nimport * as hachage from './hachage'\nimport { chiffrage } from './chiffrage'\nimport * as ed25519Utils from '@dugrema/millegrilles.utiljs/src/chiffrage.ed25519'\nimport { MESSAGE_KINDS } from '@dugrema/millegrilles.utiljs/src/constantes'\nimport pako from 'pako'\n\nexport {chiffrage}\n\nconst { hacherCertificat: _hacherCertificat } = hachage\n\nconst TAILLE_BUFFER = 1 * 1024 * 1024\n\nvar certificateStore = null   // CertificateStore pour valider x.509\nvar certificatMillegrille = null   // Objet du certificat de la MilleGrille {cert, fingerprint}\nvar _clePrivee = null\nvar formatteurMessage = null  // Formatteur de message avec signature\n\n// Conserver cle de millegrille format subtle\n// dict - cle = 'sign', 'decrypt'\nvar _cleMillegrille = null\nvar _callbackCleMillegrille = null  // Callback sur etat de la cle de millegrille\n\nexport async function initialiserCertificateStore(caCert, opts) {\n  opts = opts || {}\n  const DEBUG = opts.DEBUG\n  if(DEBUG) console.debug(\"Initialisation du CertificateStore avec %O, opts=%O\", caCert, opts)\n  certificateStore = new CertificateStore(caCert, opts)\n  if(DEBUG) console.debug(\"CertificateStore initialise %O\", certificateStore)\n\n  certificatMillegrille = {\n    pem: caCert,\n    cert: certificateStore.cert,\n    fingerprint: await _hacherCertificat(certificateStore.cert)\n  }\n}\n\nexport function setCallbackCleMillegrille(cb) {\n  // console.debug(\"Initialisation du callback pour cle de MilleGrille\")\n  _callbackCleMillegrille = cb\n}\n\nexport async function initialiserFormatteurMessage(certificatPem, clePrivee, opts) {\n  opts = opts || {}\n  _clePrivee = ed25519.privateKeyFromPem(clePrivee)\n  formatteurMessage = new FormatteurMessageEd25519(certificatPem, clePrivee)\n  await formatteurMessage.ready  // Permet de recevoir erreur si applicable\n}\n\nexport async function getFingerprintSignature() {\n  await formatteurMessage.ready  // Permet de recevoir erreur si applicable\n  return formatteurMessage.fingerprint\n}\n\nexport function clearInfoSecrete() {\n  formatteurMessage = null\n  _cleMillegrille = null\n  _clePrivee = null\n  console.info(\"Information secrete retiree de la memoire\")\n}\n\nexport function verifierCertificat(certificat, opts) {\n  /* Expose verifierChaine du certificate store */\n  if(typeof(certificat) === 'string') {\n    certificat = forgePki.certificateFromPem(certificat)\n  }\n  \n  const resultat = certificateStore.verifierChaine(certificat, opts)\n  // console.debug(\"Resultat verifier chaine : %O\", resultat)\n  return resultat?true:false\n}\n\nexport function formatterMessage(message, domaineAction, opts) {\n  opts = opts || {}\n  opts.attacherCertificat = true  // Toujours attacher le certificat\n  const kind = opts.kind\n\n  /* Expose formatterMessage du formatteur de messages */\n  if(opts.DEBUG) console.debug(\"Formatter domaine=%s, message : %O (opts: %O)\", domaineAction, message, opts)\n\n  return formatteurMessage.formatterMessage(kind, message, {...opts, domaine: domaineAction})\n}\n\nexport function signerMessageCleMillegrille(message, opts) {\n  opts = opts || {}\n\n  /* Expose formatterMessage du formatteur de messages */\n  //if(opts.DEBUG) \n  console.debug(\"Signer message avec cle de MilleGrille: %O (cle: %O)\", message, _cleMillegrille)\n  const signateur = new SignateurMessageEd25519(_cleMillegrille)\n  return signateur.signer(message)\n}\n\nexport async function _validerCertificatChiffrage(certificatPem, opts) {\n  /* Valide le certificat pour chiffrage et retourne la cle publique.\n     Le certificat doit avoir le role 'maitrecles'. */\n  opts = opts || {}\n  const DEBUG = opts.DEBUG\n\n  if(!certificateStore) throw new Error(\"CertificatStore non initialise pour verifier certificat de chiffrage\")\n\n  const certificatForge = forgePki.certificateFromPem(certificatPem)\n  if(!verifierCertificat(certificatPem, opts)) {\n    throw new Error(\"chiffrageClient._validerCertificatChiffrage Certificat forge invalide : %O\", certificatForge)\n  }\n\n  if(DEBUG) console.debug(\"Certificat forge : %O\", certificatForge)\n  // const certificatForge = await infoCertificat.cert\n  const extensions = extraireExtensionsMillegrille(certificatForge)\n  if(DEBUG) console.debug(\"Extensions MilleGrille du certificat : %O\", extensions)\n\n  const certCN = certificatForge.subject.getField('CN').value\n  if(certCN.toLowerCase() === 'millegrille') { \n    // Ok\n  } else {\n    if( ! extensions.roles.includes('maitredescles') ) {\n      throw new Error(\"Le certificat de chiffrage n'est pas pour le maitre des cles\")\n    }\n    if( ! extensions.niveauxSecurite.includes('4.secure') ) {\n      throw new Error(\"Le certificat de chiffrage n'est pas de niveau 4.secure\")\n    }\n  }\n\n  const fingerprint = await _hacherCertificat(certificatForge)\n\n  const resultat = {fingerprint}\n  if(DEBUG) console.debug(\"Resultat _validerCertificatChiffrage : %O\", resultat)\n\n  return resultat\n}\n\nexport async function chiffrerDocument(doc, domaine, certificatsChiffragePem, opts) {\n    opts = opts || {}\n    const { DEBUG, identificateurs_document } = opts\n    // console.debug(\"chiffrerDocument doc %O, identificateurs_document %O\", doc, identificateurs_document)\n    // console.debug(\"Certificat millegrille : %O\", certificatMillegrille)\n\n    // Valider les certificats de maitre des cles\n    // Conserver uniquement le premier certificat dans chaque instance de PEMs\n    const certificatsListeChiffrage = []\n    for await (const pems of certificatsChiffragePem) {\n      try {\n        // Valider le certificat - lance une Erreur si invalide\n        await _validerCertificatChiffrage(pems, opts)\n        const certificatForge = forgePki.certificateFromPem(pems[0])\n        const extensions = extraireExtensionsMillegrille(certificatForge)\n        const roles = extensions.roles || []\n        if(roles.includes('maitredescles')) {\n          certificatsListeChiffrage.push(pems[0])\n        } else {\n          console.warn(\"Certificat maitre des cles invalide - role maitredescles manquant\")\n        }\n      } catch(err) {\n        console.warn(\"Certificat maitre des cles invalide \", err)\n      }\n    }\n\n    const resultat = await chiffrage.chiffrerDocument(\n      doc, domaine, certificatMillegrille.pem, identificateurs_document, \n      {...opts, certificats: certificatsListeChiffrage}\n    )\n    console.debug(\"resultat chiffrage : %O\", resultat)\n\n    // Signer la commande de maitre des cles\n    if(formatteurMessage) {\n      const partition = resultat.commandeMaitrecles['_partition']\n      const commandeCle = {...resultat.commandeMaitrecles, '_partition': undefined}\n      const commandeMaitrecles = await formatterMessage(\n        commandeCle, 'MaitreDesCles', \n        {kind: MESSAGE_KINDS.KIND_COMMANDE, action: 'sauvegarderCle', ajouterCertificat: true, DEBUG}\n      )\n      commandeMaitrecles['attachements'] = {partition}\n      resultat.commandeMaitrecles = commandeMaitrecles\n    }\n\n    return resultat\n}\n\nexport function dechiffrerDocument(ciphertext, messageCle, opts) {\n  // Wrapper pour dechiffrer document, insere la cle privee locale\n  throw new Error(\"fix me\")\n  // return _dechiffrerDocument(ciphertext, messageCle, _clePrivee, opts)\n}\n\nexport async function chargerCleMillegrille(clePrivee) {\n  // console.debug(\"Charger cle millegrille : %O\", clePrivee)\n  if( ! _cleMillegrille ) {\n    // _cleMillegrille = clePrivee\n\n    if(typeof(clePrivee) === 'string') {\n      // Probablement format PEM\n      _cleMillegrille = ed25519.privateKeyFromPem(clePrivee)\n      _cleMillegrille.pem = clePrivee\n    } else {\n      throw new Error(\"Format de cle privee inconnu\")\n    }\n  \n  }\n\n  if(_callbackCleMillegrille) _callbackCleMillegrille(true)\n}\n\nexport async function clearCleMillegrille() {\n  _cleMillegrille = null\n  try {\n    _callbackCleMillegrille(false)\n  } catch(err) {\n    // OK\n  }\n}\n\nexport async function rechiffrerAvecCleMillegrille(\n  connexion, pemRechiffrage, setNombreClesRechiffrees, setNombreErreurs, opts) {\n  /*\n    secretsChiffres : correlation = buffer\n    pemRechiffrage : certificat a utiliser pour rechiffrer\n  */\n  opts = opts || {}\n  const DEBUG = opts.DEBUG || false,\n        batchSize = opts.batchSize || 100\n\n  if(!_cleMillegrille) {\n    throw new Error(\"Cle de MilleGrille non chargee\")\n  }\n\n  // const fingerprintsClepub = []\n  // let cleSecreteSymmetrique = null\n  // for await (const pemChain of pemRechiffrage) {\n  //   const forgeCert = forgePki.certificateFromPem(pemChain)\n  //   const publicKey = forgeCert.publicKey.publicKeyBytes\n  //   const fingerprintMaitredescles = await _hacherCertificat(forgeCert)\n\n  //   let cleChiffree = null\n  //   if(!cleSecreteSymmetrique) {\n  //     // Generer une nouvelle cle secrete\n  //     const cleGeneree = await ed25519Utils.genererCleSecrete(publicKey)\n  //     cleSecreteSymmetrique = cleGeneree.cle\n  //     cleChiffree = cleGeneree.peer\n  //   } else {\n  //     const cleGeneree = await ed25519Utils.chiffrerCle(cleSecreteSymmetrique, publicKey)\n  //     cleChiffree = cleGeneree\n  //   }\n\n  //   fingerprintsClepub.push({\n  //     partition: fingerprintMaitredescles,\n  //     publicKey,\n  //     cleSymmetrique: cleChiffree,\n  //   })\n  // }\n\n  // // console.debug(\"CleSecrete : %O, cleSecreteSymmetrique)\n\n  // if(DEBUG) console.debug(\"Rechiffrer cles avec certs %O (%O)\", fingerprintsClepub, pemRechiffrage)\n\n  let nombreClesRechiffrees = 0,\n      nombreErreurs = 0 //,\n      // plusRecenteCle = 0,\n      //excludeHachageBytes = null\n\n  let dernierePromise = null\n\n  while(true) {\n    // const clesNonDechiffrables = await connexion.requeteClesNonDechiffrables(batchSize, plusRecenteCle, excludeHachageBytes)\n    const clesNonDechiffrables = await connexion.requeteClesNonDechiffrables(batchSize, nombreClesRechiffrees)\n\n    const {/*date_creation_max,*/ cles} = clesNonDechiffrables\n    if(!cles || cles.length == 0) break\n\n    // if(clesNonDechiffrables.date_creation_max) {\n    //   if(plusRecenteCle === date_creation_max) {\n    //     console.warn(\"2 batch rechiffrage avec meme date max, on incremente pour sortir d'une boucle infinie\")\n    //     plusRecenteCle = date_creation_max + 1\n    //   } else {\n    //     plusRecenteCle = date_creation_max\n    //   }\n    // }\n    if(DEBUG) console.debug(\"Cles non dechiffrables : %O\", clesNonDechiffrables)\n    // excludeHachageBytes = cles.map(item=>item.hachage_bytes)\n\n    try {\n      //const debutRechiffrage = new Date().getTime()\n      const clesRechiffrees = []\n      //const clesRechiffrees = await Promise.all(cles.map(cle=>{\n      for await (const cle of cles) {\n        try { \n          const cleDechiffree = await ed25519Utils.dechiffrerCle(cle.cle, _cleMillegrille)\n          if(DEBUG) console.debug(\"Cle dechiffree : %O\", cleDechiffree)\n\n          const cleDechiffreeBase64 = base64.encode(cleDechiffree)\n\n          // if(Array.isArray(cleDechiffree)) {\n          //   // Convertir en uint8array\n          //   const cleDechiffreeUintArray = new Uint16Array(32)\n          //   cleDechiffreeUintArray.set(cleDechiffree)\n          //   cleDechiffree = cleDechiffreeUintArray\n          // }\n\n          // const fingerprintClesRechiffrees = {}\n          // for await (const clePub of fingerprintsClepub) {\n          //   const cleRechiffree = await ed25519Utils.chiffrerCle(cleDechiffree, clePub.publicKey)\n          //   fingerprintClesRechiffrees[clePub.partition] = cleRechiffree\n          // }\n\n          //const cleComplete = {...cle, cles: fingerprintClesRechiffrees}\n          const cleComplete = {...cle, cleSecrete: cleDechiffreeBase64}\n          delete cleComplete.cle  // Cleanup\n\n          clesRechiffrees.push(cleComplete)\n        } catch(err) {\n            console.error(\"Erreur dechiffrage cle : %O\", err)\n            nombreErreurs++\n            clesRechiffrees.push({...cle, ok: false, err: err})\n        }\n      }\n      //))\n      // const finRechiffrage = new Date().getTime()\n      // const dureeRechiffrage = finRechiffrage - debutRechiffrage\n      // console.debug(\"Duree rechiffrage cles : %d ms\", dureeRechiffrage)\n      if(DEBUG) console.debug(\"Cles rechiffrees : %O\", clesRechiffrees)\n\n      const clesPretes = clesRechiffrees.filter(cle=>cle.ok!==false)\n      const contenuDict = { \n        cles: clesPretes\n      }\n\n      console.debug(\"Contenu dict a chiffrer : \", contenuDict)\n\n      let messageBytes = JSON.stringify(contenuDict)\n      console.debug(\"Message JSON taille %d\\n%s\", messageBytes.length, messageBytes)\n      messageBytes = pako.deflate(new TextEncoder().encode(messageBytes), {gzip: true})\n      console.debug(\"Message gzip taille %d\", messageBytes.length)\n\n      const documentChiffre = await chiffrerDocument(\n        messageBytes, 'MaitreDesCles', pemRechiffrage, \n        {retourSecret: true, nojson: true, type: 'binary'}\n      )\n      console.debug(\"Contenu chiffre : \", documentChiffre)\n\n      const contenu = documentChiffre.doc.data_chiffre.slice(1),\n            dechiffrage = { header: documentChiffre.doc.header, format: documentChiffre.doc.format, cles: {}},\n            cleSecrete = documentChiffre.cleSecrete\n\n      // Rechiffrer cle secrete pour tous les maitres des cles\n      // const fingerprintsClepub = []\n      // let cleSecreteSymmetrique = null\n      for await (const pemChain of pemRechiffrage) {\n        const forgeCert = forgePki.certificateFromPem(pemChain)\n        const publicKey = forgeCert.publicKey.publicKeyBytes\n        const fingerprintMaitredescles = await _hacherCertificat(forgeCert)\n    \n        const cleChiffree = await ed25519Utils.chiffrerCle(cleSecrete, publicKey)\n        // let cleChiffree = null\n        // if(!cleSecreteSymmetrique) {\n        //   // Generer une nouvelle cle secrete\n        //   const cleGeneree = await ed25519Utils.genererCleSecrete(publicKey)\n        //   cleSecreteSymmetrique = cleGeneree.cle\n        //   cleChiffree = cleGeneree.peer\n        // } else {\n        //   const cleGeneree = await ed25519Utils.chiffrerCle(cleSecreteSymmetrique, publicKey)\n        //   cleChiffree = cleGeneree\n        // }\n    \n        dechiffrage.cles[fingerprintMaitredescles] = cleChiffree\n\n        // fingerprintsClepub.push({\n        //   partition: fingerprintMaitredescles,\n        //   publicKey,\n        //   cleSymmetrique: cleChiffree,\n        // })\n      }\n    \n      // console.debug(\"CleSecrete : %O, cleSecreteSymmetrique)\n    \n      if(DEBUG) console.debug(\"Cle rechiffree %d bytes dechiffrage: %O\", contenu.length, dechiffrage)\n\n      dernierePromise = connexion.rechiffrerClesBatch(contenu, dechiffrage)\n        .then(reponse=>{\n          if(DEBUG) console.debug(\"Reponse rechiffrerClesBatch : %O\", reponse)\n          nombreClesRechiffrees += cles.length\n        })\n        .catch(err=>{\n          console.error(\"Erreur traitement batch : %O\", err)\n        })\n        .finally(()=>{\n          setNombreClesRechiffrees(nombreClesRechiffrees)\n          setNombreErreurs(nombreErreurs)\n        })\n\n    } catch(err) {\n      console.error(\"Erreur rechiffrage batch cles : %O\", err)\n      return\n    }\n\n  }\n\n  return dernierePromise\n}\n\nexport async function chiffrerSecret(secrets, pemRechiffrage, opts) {\n  /*\n    secretsChiffres : dict correlation = buffer\n    pemRechiffrage : certificat a utiliser pour rechiffrer\n  */\n  opts = opts || {}\n  const DEBUG = opts.DEBUG\n  if(DEBUG) console.debug(\"chiffrer secrets: %O\", secrets)\n\n  // Importer la cle publique en format Subtle a partir du pem de certificat\n  const certificat = forgePki.certificateFromPem(pemRechiffrage)\n  const partition = await _hacherCertificat(certificat)\n  let clePublique = certificat.publicKey\n  if(clePublique.publicKeyBytes) clePublique = clePublique.publicKeyBytes\n  // var clePublique = forgePki.publicKeyToPem(certificat.publicKey)\n  // const regEx = /\\n?\\-{5}[A-Z ]+\\-{5}\\n?/g\n  // clePublique = clePublique.replaceAll(regEx, '')\n  // clePublique = await importerClePubliqueSubtle(clePublique)\n  if(DEBUG) console.debug(\"Cle publique extraite du pem : %O\", clePublique)\n\n  const promises = Object.keys(secrets).map(async correlation => {\n    var cleSecrete = secrets[correlation]\n    // if(typeof(buffer) === 'string') buffer = base64.decode(buffer)\n    // buffer = await chiffrerCleSecreteSubtle(clePublique, buffer)\n    if(typeof(cleSecrete) === 'string') cleSecrete = base64.decode(cleSecrete)\n    if(DEBUG) console.debug(\"Chiffrer cle secrete : %O\", cleSecrete)\n    const cleChiffree = await ed25519Utils.chiffrerCle(cleSecrete, clePublique, {ed25519: true})\n\n    if(DEBUG) console.debug(\"Cle %s chiffree : %O\", correlation, cleChiffree)\n    return {[correlation]: cleChiffree}\n  })\n\n  var resultats = await Promise.all(promises)\n  if(DEBUG) console.debug(\"Resultats rechiffrage : %O\", resultats)\n\n  // Concatener toutes les reponses\n  const secretsRechiffres = resultats.reduce((secretsRechiffres, item)=>{\n    return {...secretsRechiffres, ...item}\n  }, {})\n\n  return {cles: secretsRechiffres, partition}\n}\n\nexport function dechiffrerCleSecrete(cleSecreteChiffree, opts) {\n  opts = opts || {}\n  let cle = _clePrivee\n  if(opts.cleMillegrille) cle = _cleMillegrille\n  if(!cle) throw new Error(\"Cle privee n'est pas chargee\")\n  return ed25519Utils.dechiffrerCle(cleSecreteChiffree, cle)\n}\n\nexport function chiffrerCleSecrete(cleSecrete, clePublique, opts) {\n  opts = opts || {}\n  return ed25519Utils.chiffrerCle(cleSecrete, clePublique, opts)\n}\n\nexport function hacherCertificat(pem) {\n  if(Array.isArray(pem)) pem = pem[0]\n  const certificat = forgePki.certificateFromPem(pem)\n  return _hacherCertificat(certificat)\n}\n","import { pki as forgePki } from '@dugrema/node-forge'\n// import { forgecommon, validateurMessage, getIdmg } from '@dugrema/millegrilles.utiljs/src/index'\n\nimport { getIdmg } from '@dugrema/millegrilles.utiljs/src/idmg'\nimport { CertificateStore } from '@dugrema/millegrilles.utiljs/src/forgecommon'\nimport { verifierMessage as _verifierMessage } from '@dugrema/millegrilles.utiljs/src/validateurMessage'\n\n// const { CertificateStore } = forgecommon\n// const { verifierMessage: _verifierMessage } = validateurMessage\n// const { getIdmg } = idmg\n\nvar _certificatCaForge = null,\n    _certificateStore = null,\n    _idmgLocal = ''\n\nexport async function init(caPem) {\n  console.info(\"Init x509Client\")\n  _certificatCaForge = forgePki.certificateFromPem(caPem)\n  // console.debug(\"Certificat Store class : %O\\nCert forge : %O\", CertificateStore, _certificatCaForge)\n  _certificateStore = new CertificateStore(_certificatCaForge)\n\n  const idmg = await getIdmg(caPem)\n  _idmgLocal = idmg\n}\n\nexport function getIdmgLocal() {\n  return _idmgLocal\n}\n\nexport function verifierCertificat(chainePem, dateValidation) {\n  return _certificateStore.verifierChaine(chainePem, {validityCheckDate: dateValidation})\n}\n\nexport function validerCertificat(chainePem, dateValidation) {\n  const certificatValide = _certificateStore.verifierChaine(chainePem, {validityCheckDate: dateValidation})\n  // verifierChaine retourne false si le certificat est invalide, un objet si valide\n  if(certificatValide) {\n    // console.debug(\"Certificat valide : %O\", certificatValide)\n    return true\n  }\n  return false\n}\n\nexport async function verifierMessage(message, opts) {\n  opts = opts || {}\n  const support_idmg_tiers = opts.support_idmg_tiers?true:false\n\n  const certificat = message.certificat,\n        certMillegrille = message.millegrille\n  const estampilleInt = message.estampille\n\n  // console.debug(\"verifierMessage message %O, opts %O\", message, opts)\n\n  const estampille = new Date(estampilleInt * 1000)\n  let certValide = false\n  if(support_idmg_tiers && certMillegrille) {\n    const certCaForge = forgePki.certificateFromPem(certMillegrille)\n    const certificatStore = new CertificateStore(certCaForge)\n    certValide = certificatStore.verifierChaine(certificat, {validityCheckDate: estampille})\n  } else {\n    // Utiliser store avec CA local\n    certValide = verifierCertificat(certificat, estampille)\n  }\n\n  if(!certValide) {\n    var err = new Error(\"Certificat invalide\")\n    err.code = 1\n    err.fields = ['certificat']\n    throw err\n  }\n\n  try {\n    const certForge = forgePki.certificateFromPem(certificat[0])\n    // console.debug(\"Cert forge : \", certForge)\n    await _verifierMessage(message, certForge)\n  } catch(err) {\n    console.error(\"Erreur validation message\", err)\n    const errObj = new Error(''+err)\n    errObj.cause = err\n    errObj.code = 2\n    errObj.fields = ['hachage_contenu', '_signature']\n    throw errObj\n  }\n\n  return true\n}\n","import {io as openSocket} from 'socket.io-client'\nimport { FormatteurMessageEd25519 } from '@dugrema/millegrilles.utiljs/src/formatteurMessage'\nimport { extraireExtensionsMillegrille } from '@dugrema/millegrilles.utiljs/src/forgecommon.js'\n\nimport * as hachage from './hachage'  // Wiring hachage pour utiljs\nimport './chiffrage'\n\nimport { \n  initialiserFormatteurMessage as initialiserFormatteurMessageChiffrage,\n  formatterMessage, chargerCleMillegrille, signerMessageCleMillegrille, clearCleMillegrille,\n} from './chiffrageClient'\n\nimport {\n  init as initX509,\n  verifierCertificat,\n  verifierMessage as x509VerifierMessage,\n} from './x509Client'\nimport { KIND_COMMANDE, MESSAGE_KINDS } from '@dugrema/millegrilles.utiljs/src/constantes'\n\n// Re-exporter fonctions de chiffrageClient\nexport { formatterMessage, chargerCleMillegrille, signerMessageCleMillegrille, clearCleMillegrille } \n\nconst { hacherCertificat: _hacherCertificat } = hachage\n\nlet _socket = null,\n    _formatteurMessage = null,\n    _connecteUneFois = false,\n    _connexionCourante = null,\n    _connecxionInitialePromise = null\n\nlet _callbackSetEtatConnexion,\n    _callbackSetUsager,\n    _callbackFormatteurMessage,\n    _urlCourant = '',\n    _connecte = false,\n    _certificatsMaitreDesCles = ''\n   \nexport function setCallbacks(setEtatConnexion, callbackSetUsager, callbackFormatteurMessage) {\n  _callbackSetEtatConnexion = setEtatConnexion\n  _callbackSetUsager = callbackSetUsager\n  _callbackFormatteurMessage = callbackFormatteurMessage\n}\n\nexport async function initialiserCertificateStore(caCert, opts) {\n  opts = opts || {}\n  const DEBUG = opts.DEBUG\n  if(DEBUG) console.debug(\"Initialisation du CertificateStore avec %O\", caCert)\n  return initX509(caCert)\n}\n\nexport function estActif() {\n  return _urlCourant && _socket && _connecte\n}\n\nexport async function connecter(urlApp, opts) {\n  opts = opts || {}\n\n  if(urlApp === _urlCourant) return\n\n  if(estActif()) {\n    console.info(\"connexionClient.connecter() Connexion deja active, rien a faire\")\n    return _socket\n  }\n\n  const urlSocketio = new URL(urlApp)\n  // urlSocketio.pathname = path.join(urlSocketio.pathname, 'socket.io')\n  if(opts.DEBUG) console.debug(\"Socket.IO connecter avec url %s\", urlSocketio.href)\n\n  const connexion = connecterSocketio(urlSocketio.href, opts)\n  if(_connexionCourante) {\n    const connexionPrecedente = _connexionCourante\n    _connexionCourante = connexion\n    try {\n      // S'assurer de faire le cleanup de la connexion precedente\n      connexionPrecedente.disconnect().catch(err=>console.warn(\"Erreur deconnexion connexion remplacee (1) : %O\", err))\n    } catch(err) {\n      console.warn(\"Erreur deconnexion connexion remplacee (2) : %O\", err)\n    }\n  }\n\n  socketOn('connect', () => {\n    if(opts.DEBUG) console.debug(\"socket.io connecte a %O\", urlSocketio)\n    _connecte = true\n    _urlCourant = urlApp\n    _callbackSetEtatConnexion(_connecte)\n    onConnect(connexion).catch(err=>console.error(\"connexionClient.onConnect ERROR %O\", err))\n  })\n  socketOn('reconnect', () => {\n    if(opts.DEBUG) console.debug(\"Reconnecte\")\n    _connecte = true\n    onConnect().catch(err=>console.error(\"connexionClient.onConnect ERROR %O\", err))\n  })\n  socketOn('disconnect', reason => {\n    if(opts.DEBUG) console.debug(\"Disconnect socket.io (reason: %O)\", reason)\n    _connecte = false\n    if(_callbackSetEtatConnexion) _callbackSetEtatConnexion(false)\n    if(_callbackSetUsager) _callbackSetUsager('')\n  })\n  socketOn('connect_error', err => {\n    console.error(\"connexionClient Erreur socket.io : %O\", err)\n    _connecte = false\n    if(_callbackSetEtatConnexion) _callbackSetEtatConnexion(false)\n    if(_callbackSetUsager) _callbackSetUsager('')\n  })\n\n  return connexion\n}\n\nexport function getCertificatFormatteur() {\n  return {\n    // certificat: _formatteurMessage.cert,\n    fingerprint: _formatteurMessage.fingerprint,\n    extensions: extraireExtensionsMillegrille(_formatteurMessage.cert)\n  }\n}\n\n// Charger et conserver information backend de l'usager\nexport async function onConnect(infoPromise) {\n  // Pour la premiere connexion, infoPromise est le resultat d'une requete getEtatAuth.\n  let info = null\n  if(_connecxionInitialePromise) _connecxionInitialePromise.resolve()\n  if(infoPromise) {\n    console.debug(\"connexionClient.onConnect Connexion initiale, getEtatAuth\")\n    _connecteUneFois = true\n    info = await infoPromise\n  } else {\n    // Connexion subsequente, il faut faire une requete emitBlocking pour info session\n    info = await emitBlocking('getEtatAuth', {}, {noformat: true})\n    // console.debug(\"Reconnect info recu, marquer connecte : \", info)\n    if(_callbackSetEtatConnexion) _callbackSetEtatConnexion(_connecte, {reconnecte: true})\n  }\n\n  console.debug(\"connexionClient.onConnect %O\", info)\n  if(_callbackSetUsager && info.nomUsager) {\n    // console.debug(\"connexionClient.onConnect setUsager %s\", info.nomUsager)\n    _callbackSetUsager(info.nomUsager)\n      .catch(err=>{\n        console.error(\"connexionClient.onConnect Erreur _callbackSetUsager : %O\", err)\n      })\n  }\n}\n\nasync function connecterSocketio(url, opts) {\n  opts = opts || {}\n  const DEBUG = opts.DEBUG\n\n  // Garder polling en premier (upgrade websocket automatique)\n  // Android a un probleme avec websocket\n  const transports = opts.transports || ['websocket', 'polling']\n\n  if( _socket ) {\n    console.debug(\"SOCKET EXISTANT : %O\", _socket)\n    // const precedent = _socket\n    // try {\n    //   precedent.disconnect().catch(err=>console.warning(\"connecterSocketio Erreur deconnexion socket predecent (1) : %O\", err))\n    // } catch(err) {\n    //   console.warning(\"connecterSocketio Erreur deconnexion socket predecent (2) : %O\", err)\n    // }\n  }\n\n  const urlInfo = new URL(url)\n  const hostname = 'https://' + urlInfo.host\n  const pathSocketio = urlInfo.pathname\n\n  if(DEBUG) console.debug(\"Connecter socket.io sur %s (opts: %O)\", url, opts)\n  _socket = openSocket(hostname, {\n    path: pathSocketio,\n    reconnection: false,\n    // reconnection: true,\n    // reconnectionDelay: 2000,\n    transports,\n  })\n\n  console.info(\"connexionClient _socket ouvert : \", _socket)\n\n  let promiseMethods = null\n  try {\n    // Attendre la confirmation de connexion pour faire appel getEtatAuth\n    // Permet d'utiliser la reconnexion transparent de session avec le \n    // cookie de session (mgcookie) de webauth\n    await new Promise((resolve, reject) => {\n      if(_connecxionInitialePromise) { _connecxionInitialePromise.reject('reconnecting')}\n      const timeout = setTimeout(()=>reject('timeout'), 15_000)  // Attendre confirmation de connexion max 15 secondes\n      promiseMethods = {resolve, reject, timeout}\n      _connecxionInitialePromise = promiseMethods\n    })\n\n    try {\n      return await emitBlocking('getEtatAuth', {}, {timeout: 2500, noformat: true})\n    } catch(err) {\n      return {ok: false, err: 'getEtatAuth: '+err}\n    }\n  } catch(err) {\n    console.error(\"Erreur de connexion : %O\", err)\n  } finally {\n    if(promiseMethods && promiseMethods.timeout) clearTimeout(promiseMethods.timeout)\n    _connecxionInitialePromise = null\n  }\n\n}\n\nexport async function initialiserFormatteurMessage(certificatPem, clePriveeSign, opts) {\n  opts = opts || {}\n  const DEBUG = opts.DEBUG\n  if(DEBUG) console.debug(\"initialiserFormatteurMessage PEM:\\n%O\\n\", certificatPem)\n  _formatteurMessage = new FormatteurMessageEd25519(certificatPem, clePriveeSign, {...opts, hacheurs: hachage.hacheurs})\n\n  // Initialiser section partagee avec le chiffrageClient\n  await initialiserFormatteurMessageChiffrage(certificatPem, clePriveeSign, opts)\n\n  await _formatteurMessage.ready  // Permet de recevoir erreur si applicable\n\n  if(DEBUG) console.debug(\"connexionClient.initialiserFormatteurMessage ready\")\n  if(_callbackFormatteurMessage) _callbackFormatteurMessage(true)\n}\n\nexport function socketOn(eventName, callback) {\n  if(!_socket) {\n    console.error(\"socketOn %s, _socket === null\", eventName)\n    if(callback) callback(false)\n    return\n  }\n  _socket.on(eventName, callback)\n}\n\nexport function socketOff(eventName, callback) {\n  // console.debug(\"socketOff !!! Retrait evenement %O avec callback %O\", eventName, callback)\n  if( ! _socket ) {\n    return false\n  } else if(callback) {\n    _socket.off(eventName, callback)\n  } else {\n    _socket.removeAllListeners(eventName)\n  }\n}\n\nexport function deconnecter() {\n  /* Deconnecte et retire les information de l'usager */\n  if(_socket !== null) {\n    _socket.disconnect()\n    _socket = null\n  } else {\n    console.warn(\"_socket n'est pas initialise, on ne peut pas deconnecter\")\n  }\n  _formatteurMessage = null\n  if(_callbackFormatteurMessage) _callbackFormatteurMessage(false)\n}\n\nexport function reconnecter() {\n  if(_socket !== null) {\n    if(_socket && _socket.connected) {\n      _socket.disconnect()\n    }\n    _socket.connect()\n  }\n}\n\nexport async function verifierMessage(message) {\n  return x509VerifierMessage(message)\n}\n\nexport async function emitBlocking(event, message, opts) {\n  /* Emet un message et attend la reponse. */\n  opts = opts || {}\n  const timeoutDelay = opts.timeout || 9000,\n        attachements = opts.attachements\n\n  if(!event) throw new TypeError('connexionClient.emitBlocking event null')\n  // if(!message) throw new TypeError('connexionClient.emitBlocking message null')\n\n  if( message && !message['sig'] && opts.noformat !== true ) {\n    // Signer le message\n    const kind = message.kind || opts.kind\n    if(kind) {\n      if(!_formatteurMessage) throw new Error(\"connexionClient.emitBlocking Formatteur de message non initialise\")\n      message = await _formatteurMessage.formatterMessage(kind, message, opts)\n      // console.debug(\"connexionClient.emitBlocking Message signe \", message)\n    } else {\n      throw new Error('Il faut fournir opts.kind')\n    }\n  }\n\n  return new Promise( (resolve, reject) => {\n\n    // Creer timeout pour echec de commande\n    const timeout = setTimeout(_=>{\n      reject(new Error('emitBlocking ' + event + ': Timeout socket.io'))\n    }, timeoutDelay)\n\n    const traiterReponse = reponse => {\n      clearTimeout(timeout)  // Reponse recue, annuler le timeout\n\n      // console.debug(\"emitBlocking traiterReponse \", reponse)\n\n      if(reponse && reponse.err) return reject(reponse.err)  // Erreur cote serveur\n\n      if(reponse.sig && reponse.certificat) {\n        x509VerifierMessage(reponse)\n          .then(resultat=>{\n            // console.debug(\"Resultat validation : %O\", resultat)\n            if(resultat === true) {\n              // Parse le contenu, conserver original\n              let contenu = reponse\n              if(reponse.contenu) {\n                contenu = JSON.parse(reponse.contenu)\n                contenu['__original'] = reponse\n              }\n              resolve(contenu)\n            }\n            reject(\"Reponse invalide (hachage/signature incorrect)\")\n          })\n          .catch(err=>{\n            console.error(\"Erreur validation reponse  %O : %O\", reponse, err)\n            reject(err)\n          })\n      } else {\n        //console.warn(\"Reponse recue sans signature/cert : \", reponse)\n        resolve(reponse)\n      }\n    }\n\n    if(message) {\n      // Injecter attachments si applicable\n      if(attachements) message = {...message, attachements}\n      // Emettre message\n      _socket.emit(event, message, traiterReponse)\n    } else {\n      _socket.emit(event, traiterReponse)\n    }\n\n  })\n}\n\nexport async function emit(event, message, opts) {\n  /* Emet un message sans attente (fire and forget) */\n  opts = opts || {}\n\n  if( message && !message['sig'] && opts.noformat !== true ) {\n    // Signer le message\n    // try {\n      const kind = message.kind || opts.kind\n      if(!kind) {\n        throw new Error('Il faut fournir opts.kind')\n      }\n      message = await _formatteurMessage.formatterMessage(kind, message, opts)\n    // } catch(err) {\n    //   console.warn(\"Erreur formattage message : %O\", err)\n    // }\n  }\n\n  if(message) {\n    _socket.emit(event, message)\n  } else {\n    _socket.emit(event)\n  }\n}\n\n/**\n * \n * @param {*} nomEventSocketio Nom de l'event correspondant sur le backend de l'application\n * @param {*} cb Callback a invoquer sur chaque message\n * @param {*} params (Optionnel) Obj de parametres pour emitBlocking\n * @param {*} opts (Optionnel) Obj d'options supplementaires pour emitBlocking (e.g. pour signature du message)\n */\nexport async function subscribe(nomEventSocketio, cb, params, opts) {\n  params = params || {}\n  opts = opts || {}\n  try {\n    // var resultat = await emitBlocking(nomEventSocketio, params, {...opts, noformat: true})\n    var resultat = await emitBlocking(nomEventSocketio, params, {kind: KIND_COMMANDE, ...opts})\n  } catch(err) {\n    // Cas special lors de reconnexion a un serveur qui redemarre\n    console.warn(\"Erreur subscribe %s, attendre 5 secondes et ressayer\", nomEventSocketio)\n    // resultat = await emitBlocking(nomEventSocketio, params, {...opts, noformat: true})\n    resultat = await emitBlocking(nomEventSocketio, params, {kind: KIND_COMMANDE, ...opts})\n  }\n\n  // console.debug(\"Resultat subscribe %s : %O\", nomEventSocketio, resultat)\n  if(resultat && resultat.ok === true) {\n    resultat.routingKeys.forEach(item=>{\n      // console.debug(\"subscribe %s Ajouter socketOn %s\", nomEventSocketio, item)\n      // socketOn(item, cb)  // Note : pas sur pourquoi ca ne fonctionne pas (recoit erreur value)\n      socketOn(item, async event => {\n        const message = event.message\n        if(message.sig && message.certificat) {\n          const resultat = await x509VerifierMessage(message)\n          // console.debug(\"Resultat validation : %O\", resultat)\n          if(resultat === true) {\n            // Parse le contenu, conserver original\n            let contenu = message\n            if(message.contenu) {\n              // Remplacer event.message par contenu\n              contenu = JSON.parse(message.contenu)\n              contenu['__original'] = message\n              event.message = contenu\n            }\n            try {\n              return cb(event)\n            } catch(err) {\n              console.error(\"subscribe Erreur callback (1) : \", err)\n            }\n          } else {\n            console.error(\"subscribe callback Reponse invalide (hachage/signature incorrect) \", message)\n          }\n        } else {\n          console.warn(\"Reponse recue sans signature/cert : \", event)\n          try {\n            return await cb(event)\n          } catch(err) {\n            console.error(\"subscribe Erreur callback (2) : \", err)\n          }\n        }        \n      })\n    })\n  } else {\n    const err = new Error(\"Erreur subscribe %s\", nomEventSocketio)\n    err.reponse = resultat\n    throw err\n  }\n}\n\n/**\n * \n * @param {*} nomEventSocketio Nom de l'event correspondant sur le backend de l'application\n * @param {*} cb Callback a retirer\n */\nexport async function unsubscribe(nomEventSocketio, cb, params, opts) {\n  try {\n    params = params || {}\n    opts = opts || {}\n    socketOff(nomEventSocketio)\n    const resultat = await emitBlocking(nomEventSocketio, params, {...opts, noformat: true})\n    if(resultat && resultat.ok === true) {\n      resultat.routingKeys.forEach(item=>{\n        // socketOff(item, cb)\n        if(_socket) {\n          //_socket.off(nomEventSocketio, cb)  // voir subscribe(), on ne peut pas retirer par cb\n          _socket.removeAllListeners(item)\n        }\n      })\n    }\n  } catch(err) {\n    console.error(\"Erreur unsubscribe : %O\", err)\n  }\n}\n\nexport function isFormatteurReady() {\n  if(_formatteurMessage) {\n    const ready = _formatteurMessage.ready()\n    return ready\n  }\n  return false\n}\n\nexport function clearFormatteurMessage() {\n  _formatteurMessage = null\n  if(_callbackFormatteurMessage) _callbackFormatteurMessage(false)\n}\n\nexport async function getCertificatsMaitredescles() {\n  // console.debug(\"getCertificatsMaitredescles local \", _certificatsMaitreDesCles)\n  if(_certificatsMaitreDesCles) return _certificatsMaitreDesCles\n  const reponse = await emitBlocking('getCertificatsMaitredescles', null, {kind: MESSAGE_KINDS.KIND_REQUETE, noformat: true, ajouterCertificat: true})\n  const certificats = []\n  // console.debug(\"getCertificatsMaitredescles Reponse : \", reponse)\n  if(!reponse.err) {\n    // Valider les certificats recus\n    for await (const certificat of reponse) {\n      try {\n        const forgeCert = await verifierCertificat(certificat)\n\n        // console.debug(\"Resultat validation : %s\", forgeCert!==null)\n        if(forgeCert) {\n          const extensionCert = extraireExtensionsMillegrille(forgeCert)\n          const roles = extensionCert.roles || []\n          if(roles.includes('maitredescles')) {\n            certificats.push(certificat)\n          } else {\n            console.warn(\"Certificat sans role maitredescles, rejete\")\n          }\n        } else {\n          console.warn(\"Certificat maitre des cles invalide \", certificat)\n        }\n    \n      } catch(err) {\n        console.error(\"getCertificatsMaitredescles Erreur validation \", err)\n      }\n    }\n\n    if(certificats.length === 0) {\n      console.warn(\"Aucun certificat de maitre des cles valide n'a ete recu\")\n      return null\n    }\n\n    // Cacher la reponse\n    // console.debug(\"Cert maitre des cles mis en cache : %O\", certificats)\n    _certificatsMaitreDesCles = certificats\n    //_timeoutCertificatsMaitreDesCles = \n    setTimeout(()=>{\n      _certificatsMaitreDesCles = null\n      //_timeoutCertificatsMaitreDesCles = null\n    }, 300000)  // Clear apres 5 minutes\n  }\n  return certificats.length>0?certificats:null\n}\n\nexport function genererChallengeWebAuthn(params) {\n  // console.debug(\"Emit genererChallengeWebAuthn : %O\", params)\n  return emitBlocking('genererChallengeWebAuthn', params, {noformat: true})\n}\n\nexport function upgradeProteger(data) {\n  console.warn(\"Deprecated : connexionClient.upgradeProteger(), utiliser connexionClient.authentifier()\")\n  return authentifier(data)\n}\n\nexport async function authentifier(data, opts) {\n  opts = opts || {}\n\n  // console.debug(\"reactjs.connexionClient.Authentifier data %O, opts %O\", data, opts)\n\n  const noCallback = opts.noCallback === true\n\n  if(data) {\n      const reponse = await emitBlocking('upgrade', data, {noformat: true})\n      if(reponse.nomUsager && _callbackSetUsager) _callbackSetUsager(reponse.nomUsager)\n      return reponse\n  } else {\n      // Faire une requete pour upgrader avec le certificat\n      const reponse = await emitBlocking('genererChallengeCertificat', null, {kind: MESSAGE_KINDS.KIND_REQUETE})\n      // console.debug(\"reactjs.connexionClient.Authentifier Challenge : \", reponse)\n\n      // Repondre pour creer l'upgrade\n      const data = {...reponse.challengeCertificat}\n      // console.debug(\"reactjs.connexionClient.Authentifier Upgrade : \", data)\n      const reponseUpgrade = await emitBlocking('upgrade', data, {kind: MESSAGE_KINDS.KIND_COMMANDE, domaine: 'login', action: 'login', attacherCertificat: true})\n      // console.debug(\"reactjs.connexionClient.Authentifier Reponse upgrade \", reponseUpgrade)\n      if(!noCallback && reponseUpgrade.nomUsager && _callbackSetUsager) _callbackSetUsager(reponseUpgrade.nomUsager)\n      \n      return reponseUpgrade\n  }\n}\n","import {expose as comlinkExpose} from 'comlink'\n\nimport { MESSAGE_KINDS } from '@dugrema/millegrilles.utiljs/src/constantes'\n\n// import connexionClient from '@dugrema/millegrilles.common/lib/connexionClient'\nimport * as connexionClient from '@dugrema/millegrilles.reactjs/src/connexionClient'\n\nconst URL_SOCKET = '/millegrilles/socket.io'\n\nfunction ping() {\n  return true\n}\n\n// function connecter(opts) {\n//   opts = opts || {}\n//   const appendLog = opts.appendLog\n\n//   if(appendLog) appendLog('connexion.worker connecter')\n\n//   var url = opts.url\n//   if(!url) {\n//     // Utiliser le serveur local mais remplacer le pathname par URL_SOCKET\n//     const urlLocal = new URL(opts.location)\n//     urlLocal.pathname = URL_SOCKET\n//     urlLocal.hash = ''\n//     urlLocal.search = ''\n//     url = urlLocal.href\n//   }\n//   console.debug(\"Connecter socket.io sur url %s\", url)\n//   return connexionClient.connecter(url, {...opts, transports: ['websocket', 'polling']})\n// }\n\nfunction genererCertificatNavigateur(params) {\n  return connexionClient.emitBlocking('genererCertificatNavigateur', params, {noformat: true})\n}\n\nfunction declencherAjoutWebauthn() {\n  return connexionClient.emitBlocking('challengeAjoutWebauthn', null, {noformat: true})\n}\n\nfunction repondreChallengeRegistrationWebauthn(authResponse) {\n  return connexionClient.emitBlocking(\n    'ajouterCleWebauthn',\n    authResponse,\n    {kind: MESSAGE_KINDS.KIND_COMMANDE, domaine: 'CoreMaitreDesComptes', action: 'ajouterCle', attacherCertificat: true}\n  )\n}\n\nasync function getInfoUsager(nomUsager, opts) {\n  opts = opts || {}\n  try {\n    const reponse = await connexionClient.emitBlocking('getInfoUsager', {...opts, nomUsager}, {noformat: true})\n    return reponse\n  } catch(err) {\n    console.error(\"Erreur getInfoUsager \", err)\n    throw err\n  }\n}\n\nfunction chargerCompteUsager() {\n  // Charge le compte associe au certificat de l'usager\n  return connexionClient.emitBlocking(\n    'chargerCompteUsager', \n    {}, \n    {kind: MESSAGE_KINDS.KIND_REQUETE, domaine: 'CoreMaitreDesComptes', action: 'chargerUsager', attacherCertificat: true})\n}\n\nfunction inscrireUsager(nomUsager, csr) {\n  return connexionClient.emitBlocking('inscrireUsager', {nomUsager, csr}, {noformat: true})\n}\n\nfunction authentifierCertificat(challenge) {\n  return connexionClient.emitBlocking(\n    'authentifierCertificat',\n    {...challenge},\n    {kind: MESSAGE_KINDS.KIND_COMMANDE, domaine: 'login', attacherCertificat: true}\n  )\n}\n\nasync function authentifierWebauthn(data, opts) {\n  opts = opts || {}\n  const noformat = opts.noformat === false?false:true  // Default a true, on peut forcer false pour Signer\n  const attacherCertificat = !noformat\n  try {\n    // const dataStr = JSON.parse(JSON.stringify(data))\n    // console.debug(\"Emettre : %O\", dataStr)\n    console.debug(\"authentifierWebauthn Emettre : %O\", data)\n    const reponse = await connexionClient.emitBlocking(\n      'authentifierWebauthn',\n      data,\n      {\n        kind: MESSAGE_KINDS.KIND_COMMANDE, domaine: 'MaitreDesComptes', \n        noformat: true,\n        // attacherCertificat, noformat, // pour cas ou certificat absent\n      }\n    )\n    console.debug(\"Reponse \", reponse)\n    return reponse\n  } catch(err) {\n    console.error(\"Erreur emitBlocking authentifierWebauthn\", err)\n    throw err\n  }\n}\n\nfunction authentifierCleMillegrille(data) {\n  console.debug(\"authentifierCleMillegrille %O\", data)\n  return connexionClient.emitBlocking('authentifierCleMillegrille', data, {noformat: true})\n}\n\n// function ecouterFingerprintPk(fingerprintPk, cb) {\n//   connexionClient.socketOn('fingerprintPk', cb)\n//   return connexionClient.emitBlocking('ecouterFingerprintPk', {fingerprintPk}, {noformat: true})\n// }\n\n// function arretFingerprintPk(fingerprintPk, cb) {\n//   connexionClient.socketOff('fingerprintPk')\n//   // return connexionClient.emitBlocking('ecouterFingerprintPk', {fingerprintPk}, {noformat: true})\n// }\n\nfunction getChallengeDelegation() {\n  return connexionClient.emitBlocking('getChallengeDelegation', {}, {kind: MESSAGE_KINDS.KIND_COMMANDE})\n}\n\nfunction requeteListeApplications(cb) {\n  return connexionClient.emitBlocking(\n    'topologie/listeApplicationsDeployees',\n    {},\n    {kind: MESSAGE_KINDS.KIND_REQUETE, domaine: 'CoreTopologie', action: 'listeApplicationsDeployees', attacherCertificat: true}\n  )\n}\n\nfunction activerDelegationParCleMillegrille(commande) {\n  return connexionClient.emitBlocking(\n    'activerDelegationParCleMillegrille',\n    commande,\n    {kind: MESSAGE_KINDS.KIND_COMMANDE, domaine: 'CoreMaitreDesComptes', action: 'ajouterDelegationSignee', attacherCertificat: true}\n  )\n}\n\nfunction ajouterCsrRecovery(nomUsager, csr) {\n  // Commande \"publique\" (utilisee sans authentification)\n  return connexionClient.emitBlocking('ajouterCsrRecovery', {nomUsager, csr}, {kind: MESSAGE_KINDS.KIND_COMMANDE, noformat: true})\n}\n\nfunction getRecoveryCsr(code) {\n  return connexionClient.emitBlocking(\n    'getRecoveryCsr', \n    {code}, \n    {kind: MESSAGE_KINDS.KIND_COMMANDE, domaine: 'CoreMaitreDesComptes', action: 'getCsrRecoveryParcode', attacherCertificat: true}\n  )\n}\n\nfunction signerRecoveryCsr(commande) {\n  return connexionClient.emitBlocking(\n    'signerRecoveryCsr', \n    commande, \n    {kind: MESSAGE_KINDS.KIND_COMMANDE, domaine: 'CoreMaitreDesComptes', action: 'signerCompteUsager', attacherCertificat: true}\n  )\n}\n\nfunction genererChallenge(commande) {\n  return connexionClient.emitBlocking(\n    'genererChallenge', \n    commande, \n    {kind: MESSAGE_KINDS.KIND_COMMANDE, domaine: 'CoreMaitreDesComptes', action: 'genererChallenge', attacherCertificat: true}\n  )\n}\n\nfunction signerCompteUsager(commande) {\n  return connexionClient.emitBlocking(\n    'signerCompteUsager', \n    commande, \n    {kind: MESSAGE_KINDS.KIND_COMMANDE, domaine: 'CoreMaitreDesComptes', action: 'signerCompteUsager', attacherCertificat: true}\n  )\n}\n\n// Listeners\nfunction enregistrerCallbackEvenementsActivationFingerprint(fingerprintPk, cb) { \n  return connexionClient.subscribe('ecouterEvenementsActivationFingerprint', cb, {fingerprintPk}, {noformat: true}) \n}\n\nfunction retirerCallbackEvenementsActivationFingerprint(fingerprintPk, cb) { \n  return connexionClient.unsubscribe('retirerEvenementsActivationFingerprint', cb, {fingerprintPk}, {noformat: true}) \n}\n\ncomlinkExpose({\n ...connexionClient, \n  ping,\n  // connecter,  // Override de connexionClient.connecter\n\n  chargerCompteUsager,\n\n  inscrireUsager, declencherAjoutWebauthn,\n  genererCertificatNavigateur,\n  repondreChallengeRegistrationWebauthn, getInfoUsager,\n  authentifierCertificat, authentifierWebauthn, authentifierCleMillegrille,\n  /* ecouterFingerprintPk, arretFingerprintPk, */\n  requeteListeApplications,\n  activerDelegationParCleMillegrille, ajouterCsrRecovery, getRecoveryCsr, signerRecoveryCsr,\n  getChallengeDelegation,\n  genererChallenge, signerCompteUsager,\n\n  // Listeners\n  enregistrerCallbackEvenementsActivationFingerprint, retirerCallbackEvenementsActivationFingerprint,\n\n})\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [414,802,888], function() { return __webpack_require__(65569); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + {\"414\":\"63a06a7d\",\"802\":\"ad904b7e\",\"888\":\"42dc0549\"}[chunkId] + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = function(module) {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.p = \"/millegrilles/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t297: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkmillegrilles_maitredescomptes_client\"] = self[\"webpackChunkmillegrilles_maitredescomptes_client\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn Promise.all([414,802,888].map(__webpack_require__.e, __webpack_require__)).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["constructeur","methode","hacheur","update","buffer","finalize","digest","hacheurs","createSHA256","createSHA512","createBLAKE2s","createBLAKE2b","setHacheurs","DECIPHER_MESSAGE_SIZE","MESSAGE_SIZE","data","opts","key","nonce","base64","decode","getRandom","_sodium","sodium","crypto_aead_chacha20poly1305_ietf_encrypt_detached","ciphertext","tag","mac","CipherError","hacher","hachage","tagStr","encode","nonceStr","rawTag","format","Uint8Array","from","crypto_aead_chacha20poly1305_ietf_decrypt_detached","DecipherError","creerStreamCipherXChacha20Poly1305","digestAlgo","messageBuffer","positionBuffer","tailleOutput","Hacheur","hashingCode","ready","res","crypto_secretstream_xchacha20poly1305_init_push","state_out","state","header","etatFinal","length","endPos","set","slice","ciphertextMessage","crypto_secretstream_xchacha20poly1305_push","crypto_secretstream_xchacha20poly1305_TAG_MESSAGE","crypto_secretstream_xchacha20poly1305_TAG_FINAL","taille","creerStreamDecipherXChacha20Poly1305","state_in","crypto_secretstream_xchacha20poly1305_init_pull","output","positionOuputMessage","resultatDechiffrage","crypto_secretstream_xchacha20poly1305_pull","message","resultat","decipheredMessage","cipher","tailleBuffer","Math","ceil","positionLecture","positionEcriture","tailleLecture","min","dataSlice","decipher","cipherSlice","Error","NonSupporteError","streamXchacha20poly1305Algorithm","encrypt","decrypt","decryptStreamXChacha20Poly1305","getCipher","getDecipher","messageSize","stream","chacha20poly1305Algorithm","decryptChacha20Poly1305","iv","nonSupporte","dummy","ciphers","setCiphers","formatteurMessage","_cleMillegrille","_callbackCleMillegrille","initialiserFormatteurMessage","certificatPem","clePrivee","ed25519","privateKeyFromPem","FormatteurMessageEd25519","formatterMessage","domaineAction","attacherCertificat","kind","DEBUG","console","debug","domaine","signerMessageCleMillegrille","SignateurMessageEd25519","signer","chargerCleMillegrille","pem","clearCleMillegrille","err","_certificatCaForge","_certificateStore","init","caPem","info","forgePki","certificateFromPem","CertificateStore","getIdmg","idmg","verifierCertificat","chainePem","dateValidation","verifierChaine","validityCheckDate","verifierMessage","support_idmg_tiers","certificat","certMillegrille","millegrille","estampilleInt","estampille","Date","certValide","certCaForge","certificatStore","code","fields","certForge","_verifierMessage","error","errObj","cause","_callbackSetEtatConnexion","_callbackSetUsager","_callbackFormatteurMessage","_socket","_formatteurMessage","_connexionCourante","_connecxionInitialePromise","_urlCourant","_connecte","_certificatsMaitreDesCles","setCallbacks","setEtatConnexion","callbackSetUsager","callbackFormatteurMessage","initialiserCertificateStore","caCert","initX509","estActif","connecter","urlApp","urlSocketio","URL","href","connexion","connecterSocketio","connexionPrecedente","disconnect","catch","warn","socketOn","onConnect","reason","getCertificatFormatteur","fingerprint","extensions","extraireExtensionsMillegrille","cert","infoPromise","resolve","emitBlocking","noformat","reconnecte","nomUsager","url","transports","urlInfo","hostname","host","pathSocketio","pathname","openSocket","path","reconnection","promiseMethods","Promise","reject","timeout","setTimeout","ok","clearTimeout","clePriveeSign","initialiserFormatteurMessageChiffrage","eventName","callback","on","socketOff","off","removeAllListeners","deconnecter","reconnecter","connected","connect","x509VerifierMessage","event","timeoutDelay","attachements","TypeError","_","traiterReponse","reponse","sig","then","contenu","JSON","parse","emit","subscribe","nomEventSocketio","cb","params","KIND_COMMANDE","routingKeys","forEach","item","unsubscribe","isFormatteurReady","clearFormatteurMessage","getCertificatsMaitredescles","MESSAGE_KINDS","KIND_REQUETE","ajouterCertificat","certificats","forgeCert","extensionCert","roles","includes","push","genererChallengeWebAuthn","upgradeProteger","authentifier","noCallback","challengeCertificat","action","reponseUpgrade","connexionClient","comlinkExpose","ping","chargerCompteUsager","inscrireUsager","csr","declencherAjoutWebauthn","genererCertificatNavigateur","repondreChallengeRegistrationWebauthn","authResponse","getInfoUsager","authentifierCertificat","challenge","authentifierWebauthn","authentifierCleMillegrille","requeteListeApplications","activerDelegationParCleMillegrille","commande","ajouterCsrRecovery","getRecoveryCsr","signerRecoveryCsr","getChallengeDelegation","genererChallenge","signerCompteUsager","enregistrerCallbackEvenementsActivationFingerprint","fingerprintPk","retirerCallbackEvenementsActivationFingerprint","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","id","loaded","__webpack_modules__","call","m","x","__webpack_exports__","O","deferred","result","chunkIds","fn","priority","notFulfilled","Infinity","i","fulfilled","j","Object","keys","every","splice","r","n","getter","__esModule","d","a","definition","o","defineProperty","enumerable","get","f","e","chunkId","all","reduce","promises","u","miniCssF","g","globalThis","this","Function","window","obj","prop","prototype","hasOwnProperty","Symbol","toStringTag","value","nmd","paths","children","p","installedChunks","importScripts","chunkLoadingGlobal","self","parentChunkLoadingFunction","bind","moreModules","runtime","pop","next","map"],"sourceRoot":""}