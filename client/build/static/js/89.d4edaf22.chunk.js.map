{"version":3,"file":"static/js/89.d4edaf22.chunk.js","mappings":"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","sources":["../../../../git/millegrilles.reactjs/src/webauthn.js","WebAuthn.js","comptesUtil.js","../../../../git/millegrilles.reactjs/src/hachage.js"],"sourcesContent":["import multibase from 'multibase'\nimport base64url from 'base64url'\n\nexport async function repondreRegistrationChallenge(nomUsager, challengeWebauthn, opts) {\n  opts = opts || {}\n  const DEBUG = opts.DEBUG\n\n  if(DEBUG) console.debug('repondreRegistrationChallenge nomUsager: %s, attestation: %O', nomUsager, challengeWebauthn)\n  // Parse options, remplacer base64 par buffer\n  const challenge = Buffer.from(challengeWebauthn.challenge, 'base64')  // multibase.decode(publicKey.challenge)\n  const attestation = challengeWebauthn.attestation\n  const userId = Buffer.from(challengeWebauthn.user.id, 'base64')  // multibase.decode(publicKey.user.id)\n\n  const publicKey = {\n    ...challengeWebauthn,\n    challenge,\n    user: {\n      ...challengeWebauthn.user,\n      id: userId,\n      name: nomUsager,\n      displayName: nomUsager,\n    }\n  }\n\n  // Cle publique\n  if(DEBUG) console.debug(\"Registration options avec buffers : %O\", publicKey)\n  const newCredential = await navigator.credentials.create({publicKey})\n  if(DEBUG) console.debug(\"New credential : %O\", newCredential)\n\n  // Transmettre reponse\n  const credentialResponse = newCredential.response\n  const jsonData = base64url.encode(credentialResponse.clientDataJSON)\n  const attestationObject = base64url.encode(new Uint8Array(credentialResponse.attestationObject))\n  const data = {\n    id: newCredential.id,\n    response: {\n      attestationObject,\n      clientDataJSON: jsonData,\n    },\n    type: newCredential.type,\n  }\n\n  return data\n}\n","import {useState, useEffect, useCallback} from 'react'\nimport Button from 'react-bootstrap/Button'\nimport base64url from 'base64url'\nimport axios from 'axios'\n\nimport { usagerDao, BoutonActif } from '@dugrema/millegrilles.reactjs'\nimport { repondreRegistrationChallenge } from '@dugrema/millegrilles.reactjs/src/webauthn.js'\nimport { hacherMessage } from '@dugrema/millegrilles.reactjs/src/formatteurMessage'\n\nimport useWorkers, { useUsagerDb, useUsagerSocketIo } from './WorkerContext'\n\nimport { sauvegarderCertificatPem, genererCle, chargerUsager } from './comptesUtil'\n\nexport function BoutonAjouterWebauthn(props) {\n\n    const { variant, className, resetMethodes, confirmationCb, erreurCb } = props\n\n    const workers = useWorkers()\n\n    const { connexion } = workers\n    const usagerDb = useUsagerDb()[0]\n    const nomUsager = usagerDb.nomUsager,\n          fingerprintPkCourant = usagerDb.fingerprintPk\n\n    const [challenge, setChallenge] = useState('')\n    const [resultat, setResultat] = useState('')\n\n    const onClickCb = useCallback(event=>{\n        setResultat('attente')\n        event.preventDefault()\n        event.stopPropagation()\n        \n        console.debug(\"Ajout methode pour nomUsager %s, fingerprintPkCourant %O, challenge %O\", \n            nomUsager, fingerprintPkCourant, challenge)\n\n        ajouterMethode(connexion, nomUsager, fingerprintPkCourant, challenge, resetMethodes, {DEBUG: true})\n            .then( resultat => {\n                console.debug(\"Resultat ajouter methode : \", resultat)\n                setResultat('succes')\n                if(confirmationCb) confirmationCb()\n            })\n            .catch(err=>{\n                setResultat('echec')\n                erreurCb(err, 'Erreur ajouter methode')\n            })\n    }, [connexion, nomUsager, fingerprintPkCourant, challenge, resetMethodes, confirmationCb, erreurCb, setResultat])\n\n    useEffect(() => {\n        getChallengeAjouter(connexion)\n            .then(challenge=>{\n                console.debug(\"BoutonAjouterWebauthn Challenge registration : \", challenge)\n                setChallenge(challenge)\n            })\n            .catch(err=>erreurCb(err, 'Erreur preparation challenge pour ajouter methode'))\n    },[connexion, setChallenge, confirmationCb, erreurCb])\n\n    return (\n        <BoutonActif\n            variant={variant} \n            className={className} \n            etat={resultat}\n            onClick={onClickCb}\n            disabled={challenge?false:true}\n        >\n            {props.children}\n        </BoutonActif>\n    )\n\n}\n\nexport function BoutonAuthentifierWebauthn(props) {\n\n    const { variant, className, usagerDb, challenge, dureeSession, onError, onSuccess } = props\n\n    const workers = useWorkers()\n\n    console.debug(\"BoutonAuthentifierWebauthn usagerDb %O\", usagerDb)\n\n    const { connexion } = workers\n    // const { requete: requeteCsr } = usagerDbLocal\n    const nomUsager = usagerDb.nomUsager\n    const requeteCsr = usagerDb.requete\n\n    const [reponseChallengeAuthentifier, setReponseChallengeAuthentifier] = useState('')\n    const [attente, setAttente] = useState(false)\n    const [erreur, setErreur] = useState(false)\n    const handlerErreur = useCallback((err, message)=>{\n        setErreur(true)\n        onError(err, message)\n    }, [setErreur, onError])\n\n    const authentifierCb = useCallback( event => {\n        console.debug(\"BoutonAuthentifierWebauthn.authentifierCb Authentifier reponseChallengeAuthentifier: %O\", reponseChallengeAuthentifier)\n        setErreur(false)  // Reset\n        setAttente(true)\n        const {demandeCertificat, publicKey} = reponseChallengeAuthentifier\n        authentifier(connexion, nomUsager, demandeCertificat, publicKey, {dureeSession})\n            .then(reponse=>{\n                console.debug(\"BoutonAuthentifierWebauthn Reponse authentifier \", reponse)\n\n                // if(reponse.cookie_disponible) {\n                //     console.debug(\"Recuperer le cookie de session\")\n                //     axios({method: 'GET', url: '/millegrilles/authentification/cookie'})\n                //         .then(reponse=>{\n                //             console.debug(\"Reponse recuperer cookie de session : \", reponse)\n                //         })\n                //         .catch(err=>console.error(\"Erreur recuperation cookie de session \", err))\n                // }\n                onSuccess(reponse)\n            })\n            .catch(err=>handlerErreur(err, 'BoutonAuthentifierWebauthn.authentifierCb Erreur authentification'))\n            .finally(()=>{setAttente(false)})\n    }, [connexion, nomUsager, dureeSession, reponseChallengeAuthentifier, onSuccess, setAttente, setErreur, handlerErreur])\n\n    useEffect(()=>{\n        if(!challenge) return\n        preparerAuthentification(nomUsager, challenge, requeteCsr)\n            .then(resultat=>{\n                console.debug(\"Reponse preparerAuthentification nomUsager %s, challenge %O, requeteCsr %s : %O\", nomUsager, challenge, requeteCsr, resultat)\n                setReponseChallengeAuthentifier(resultat)\n            })\n            .catch(err=>onError(err, 'BoutonAuthentifierWebauthn.authentifierCb Erreur preparation authentification'))\n    }, [nomUsager, challenge, requeteCsr, setReponseChallengeAuthentifier, onError])\n\n    let etatBouton = ''\n    if(erreur) etatBouton = 'echec'\n    else if(attente) etatBouton = 'attente'\n\n    return (\n        <BoutonActif \n            variant={variant} \n            className={className} \n            challenge={challenge}\n            etat={etatBouton}\n            onClick={authentifierCb}\n            disabled={reponseChallengeAuthentifier?false:true}\n        >\n            {props.children}\n        </BoutonActif>\n    )\n}\n\nexport function BoutonMajCertificatWebauthn(props) {\n\n    const { \n        variant, className, usager, setAttente, onSuccess, onError,\n    } = props\n\n    const workers = useWorkers()\n\n    const { nomUsager, requete } = usager || {}\n\n    // const [nouvelleCleCsr, setNouvelleCleCsr] = useState('')\n    const [csrChallenge, setCsrChallenge] = useState('')\n\n    const majCertificatCb = useCallback(()=>{\n        if(setAttente) setAttente(true)\n        console.debug(\"majCertificatCb requete : %O, csrChallenge: %O\", requete, csrChallenge)\n        const { demandeCertificat, publicKey, challengeReference } = csrChallenge\n        \n        majCertificat(workers, nomUsager, demandeCertificat, publicKey, challengeReference)\n            .then(reponse=>{if(onSuccess) onSuccess(reponse)})\n            .catch(err=>{if(onError) onError(err); else console.error(\"Erreur : %O\", err)})\n            .finally(()=>{if(setAttente) setAttente(false)})\n    }, [\n        workers, nomUsager, requete, csrChallenge,\n        setAttente, onSuccess, onError\n    ])\n\n    // Charger un nouveau challenge\n    useEffect(()=>{\n        if(!nomUsager || !requete) return\n        // chargerUsager(nomUsager, null, null, {genererChallenge: true})\n        //     .then(reponse=>{\n        //         console.debug(\"BoutonMajCertificatWebauthn reponse charger usager : \", reponse)\n        //         return preparerAuthentification(nomUsager, reponse.infoUsager.authentication_challenge, requete)\n        //     })\n        //     .then(setCsrChallenge)\n        //     .catch(onError)\n        const hostname = window.location.hostname\n        workers.connexion.genererChallenge({hostname, webauthnAuthentication: true})\n            .then(async reponse => {\n                console.debug(\"BoutonMajCertificatWebauthn Reponse challenge \", reponse)\n                const csrChallenge = await preparerAuthentification(nomUsager, reponse.authentication_challenge, requete)\n                console.debug(\"BoutonMajCertificatWebauthn CSR Challenge \", csrChallenge)\n                setCsrChallenge(csrChallenge)\n            })\n            .catch(onError)\n        \n    }, [workers, nomUsager, requete, setCsrChallenge, onError])\n\n    return (\n        <Button \n            variant={variant} \n            className={className} \n            onClick={majCertificatCb}\n            disabled={csrChallenge?false:true}>\n            {props.children}\n        </Button>\n    )\n}\n\nexport async function preparerNouveauCertificat(workers, nomUsager) {\n    const {connexion} = workers\n    const cleCsr = await genererCle(nomUsager)\n    console.debug(\"Nouvelle cle generee : %O\", cleCsr)\n\n    const hostname = window.location.hostname\n    const infoUsager = await connexion.getInfoUsager(nomUsager, {hostname, genererChallenge: true})\n    console.debug(\"Etat usager backend : %O\", infoUsager)\n    const challenge = infoUsager.authentication_challenge\n    if(!challenge) return null\n    const reponseChallengeAuthentifier = await preparerAuthentification(nomUsager, challenge, cleCsr)\n    \n    return {cleCsr, challengeWebAuthn: challenge, reponseChallengeAuthentifier}\n}\n\nasync function majCertificat(workers, nomUsager, demandeCertificat, publicKey, challengeReference) {\n    const {connexion} = workers\n    // const reponse = await authentifier(connexion, nomUsager, demandeCertificat, publicKey, {noformat: false})\n\n    console.debug(\"majCertificat signer %O / publicKey %O, challenge reference : %O\", demandeCertificat, publicKey, challengeReference)\n    const demandeSignee = await signerDemandeAuthentification(nomUsager, demandeCertificat, publicKey)\n    \n    console.debug(\"majCertificat Demande certificat signee avec webauthn : %O\", demandeSignee)\n\n    const commande = {\n        demandeCertificat: demandeSignee.demandeCertificat,\n        challenge: challengeReference,\n        hostname: window.location.hostname,\n        clientAssertionResponse: demandeSignee.webauthn,\n    }\n\n    const reponse = await connexion.signerCompteUsager(commande)\n    return reponse\n}\n\nasync function getChallengeAjouter(connexion) {\n    console.debug(\"Charger challenge ajouter webauthn\")\n    \n    const hostname = window.location.hostname\n    /*\n            const hostname = window.location.hostname\n            workers.connexion.genererChallenge({\n                hostname,\n                webauthnAuthentication: true\n            }).then(reponseChallenge=>{\n                console.debug(\"Challenge webauthn : \", reponseChallenge)\n                const authenticationChallenge = reponseChallenge.authentication_challenge\n                setChallengeOriginal(authenticationChallenge.publicKey.challenge)\n                return preparerAuthentification(nomUsager, authenticationChallenge, csr, {activationTierce: true})\n            })\n            .then(challengePrepare=>{\n                console.debug(\"Challenge webauthn prepare : \", challengePrepare)\n                setPreparationWebauthn(challengePrepare)\n            })\n            .catch(erreurCb)\n    */\n\n    const challengeWebauthn = await connexion.genererChallenge({\n        hostname, webauthnRegistration: true\n    })\n    console.debug(\"Challenge : %O\", challengeWebauthn)\n    return challengeWebauthn.registration_challenge\n}\n\nasync function ajouterMethode(connexion, nomUsager, fingerprintPk, challenge, resetMethodes, opts) {\n    opts = opts || {}\n    // console.debug(\"Ajouter webauthn pour usager %s\", nomUsager)\n\n    // NB : Pour que l'enregistrement avec iOS fonctionne bien, il faut que la\n    //      thread de l'evenement soit la meme que celle qui declenche\n    //      navigator.credentials.create({publicKey}) sous repondreRegistrationChallenge\n    if(challenge.publicKey) challenge = challenge.publicKey\n    const reponse = await repondreRegistrationChallenge(nomUsager, challenge, opts)\n    console.debug(\"Reponse ajout webauthn : %O\", reponse)\n\n    const hostname = window.location.hostname\n\n    const params = {\n        reponseChallenge: reponse,\n        fingerprintPk,\n        hostname,\n    }\n\n    if(resetMethodes) {\n        params.reset_cles = true\n    }\n\n    console.debug(\"reponseChallenge : %O\", params)\n\n    const resultatAjout = await connexion.repondreChallengeRegistrationWebauthn(params)\n    console.debug(\"Resultat ajout : %O\", resultatAjout)\n    if(resultatAjout.ok !== true) {\n        const error = new Error(\"Erreur, ajout methode refusee (back-end)\")\n        error.reponse = resultatAjout\n        throw error\n    }\n}\n\nexport async function preparerAuthentification(nomUsager, challengeWebauthn, requete, opts) {\n    opts = opts || {}\n    if(!challengeWebauthn) throw new Error(\"preparerAuthentification challengeWebauthn absent\")\n    console.debug(\"Preparer authentification avec : \", challengeWebauthn)\n\n    const challengeReference = challengeWebauthn.publicKey.challenge\n    const publicKey = {...challengeWebauthn.publicKey}\n\n    // Decoder les champs base64url\n    publicKey.challenge = base64url.toBuffer(publicKey.challenge)\n    publicKey.allowCredentials = (publicKey.allowCredentials || []).map(cred=>{\n        const idBytes = base64url.toBuffer(cred.id)\n        return {\n            ...cred,\n            id: idBytes\n        }\n    })\n\n    let demandeCertificat = null\n    if(requete) {\n        const csr = requete.csr || requete\n        // console.debug(\"On va hacher le CSR et utiliser le hachage dans le challenge pour faire une demande de certificat\")\n        // if(props.appendLog) props.appendLog(`On va hacher le CSR et utiliser le hachage dans le challenge pour faire une demande de certificat`)\n        demandeCertificat = {\n            nomUsager,\n            csr,\n            date: Math.floor(new Date().getTime()/1000)\n        }\n        if(opts.activationTierce === true) demandeCertificat.activationTierce = true\n        const hachageDemandeCert = await hacherMessage(demandeCertificat, {bytesOnly: true, hashingCode: 'blake2s-256'})\n        console.debug(\"Hachage demande cert %O = %O, ajouter au challenge existant de : %O\", hachageDemandeCert, demandeCertificat, publicKey.challenge)\n        \n        // Concatener le challenge recu (32 bytes) au hachage de la commande\n        // Permet de signer la commande de demande de certificat avec webauthn\n        const challengeMaj = new Uint8Array(64)\n        challengeMaj.set(publicKey.challenge, 0)\n        challengeMaj.set(hachageDemandeCert, 32)\n        publicKey.challenge = challengeMaj\n\n        //challenge[0] = CONST_COMMANDE_SIGNER_CSR\n        //challenge.set(hachageDemandeCert, 1)  // Override bytes 1-65 du challenge\n        console.debug(\"Challenge override pour demander signature certificat : %O\", publicKey.challenge)\n        // if(props.appendLog) props.appendLog(`Hachage demande cert ${JSON.stringify(hachageDemandeCert)}`)\n    } \n    // else if(challenge[0] !== CONST_COMMANDE_AUTH) {\n    //     console.error(\"Challenge[0] : %d !== %d\", challenge[0], CONST_COMMANDE_AUTH)\n    //     throw new Error(\"Erreur challenge n'est pas de type authentification (code!==1)\")\n    // }        \n\n    const resultat = { publicKey, demandeCertificat, challengeReference }\n    console.debug(\"Prep publicKey/demandeCertificat : %O\", resultat)\n    \n    return resultat\n}\n\nasync function authentifier(connexion, nomUsager, demandeCertificat, publicKey, opts) {\n    // N.B. La methode doit etre appelee par la meme thread que l'event pour supporter\n    //      TouchID sur iOS.\n    console.debug(\"Signer challenge : %O (opts: %O)\", publicKey, opts)\n    // if(opts.appendLog) opts.appendLog(`Signer challenge`)\n\n    opts = opts || {}\n    const { dureeSession } = opts\n\n    if(!nomUsager) throw new Error(\"authentifier Nom usager manquant\")  // Race condition ... pas encore trouve\n\n    const data = await signerDemandeAuthentification(nomUsager, demandeCertificat, publicKey, {connexion, dureeSession})\n\n    // console.debug(\"Data a soumettre pour reponse webauthn : %O\", data)\n    // const resultatAuthentification = await connexion.authentifierWebauthn(data, opts)\n    // console.debug(\"Resultat authentification : %O\", resultatAuthentification)\n    // // const contenu = JSON.parse(resultatAuthentification.contenu)\n\n    console.debug(\"Data a soumettre pour reponse webauthn : %O\", data)\n    const resultatAuthentification = await axios.post('/auth/authentifier_usager', data)\n    console.debug(\"Resultat authentification : %O\", resultatAuthentification)\n    const reponse = resultatAuthentification.data\n    const contenu = JSON.parse(reponse.contenu)\n\n    if(contenu.userId) {\n        return contenu\n    } else {\n        throw new Error(\"WebAuthn.authentifier Erreur authentification\")\n    }\n}\n\nexport async function signerDemandeAuthentification(nomUsager, demandeCertificat, publicKey, opts) {\n    opts = opts || {}\n    // const connexion = opts.connexion\n    // N.B. La methode doit etre appelee par la meme thread que l'event pour supporter\n    //      TouchID sur iOS.\n    // console.debug(\"Signer challenge : %O (challengeWebauthn %O, opts: %O)\", publicKey, challengeWebauthn, opts)\n    // if(opts.appendLog) opts.appendLog(`Signer challenge`)\n\n    if(!nomUsager) throw new Error(\"signerDemandeAuthentification Nom usager manquant\")  // Race condition ... pas encore trouve\n\n    let { dureeSession } = opts\n    if(typeof(dureeSession) === 'string') {\n        dureeSession = Number.parseInt(dureeSession)\n    }\n\n    // S'assurer qu'on a un challenge de type 'authentification'\n    // const demandeCertificat = opts.demandeCertificat?opts.demandeCertificat:null\n    const data = {nomUsager, demandeCertificat}\n    if(dureeSession) data.dureeSession = dureeSession\n    \n    const publicKeyCredentialSignee = await navigator.credentials.get({publicKey})\n    // console.debug(\"PublicKeyCredential signee : %O\", publicKeyCredentialSignee)\n    // if(opts.appendLog) opts.appendLog(`PublicKeyCredential signee : ${JSON.stringify(publicKeyCredentialSignee)}`)\n\n    const reponseSignee = publicKeyCredentialSignee.response\n\n    const reponseSerialisable = {\n        // id: publicKeyCredentialSignee.rawId,\n        // id64: base64.encode(new Uint8Array(publicKeyCredentialSignee.rawId)),  // String.fromCharCode.apply(null, multibase.encode('base64', new Uint8Array(publicKeyCredentialSignee.rawId))),\n        id64: base64url.encode(new Uint8Array(publicKeyCredentialSignee.rawId)),\n        response: {\n            // authenticatorData: reponseSignee.authenticatorData?base64.encode(new Uint8Array(reponseSignee.authenticatorData)):null,\n            // clientDataJSON: reponseSignee.clientDataJSON?base64.encode(new Uint8Array(reponseSignee.clientDataJSON)):null,\n            // signature: reponseSignee.signature?base64.encode(new Uint8Array(reponseSignee.signature)):null,\n            // userHandle: reponseSignee.userHandle?base64.encode(new Uint8Array(reponseSignee.userHandle)):null,\n\n            authenticatorData: reponseSignee.authenticatorData?base64url.encode(new Uint8Array(reponseSignee.authenticatorData)):null,\n            clientDataJSON: reponseSignee.clientDataJSON?base64url.encode(new Uint8Array(reponseSignee.clientDataJSON)):null,\n            signature: reponseSignee.signature?base64url.encode(new Uint8Array(reponseSignee.signature)):null,\n            userHandle: reponseSignee.userHandle?base64url.encode(new Uint8Array(reponseSignee.userHandle)):null,\n        },\n        type: publicKeyCredentialSignee.type,\n    }\n\n    console.debug(\"Reponse serialisable : %O\", reponseSerialisable)\n\n    data.webauthn = reponseSerialisable\n    data.challenge = publicKey.challenge\n\n    return data\n}\n","import axios from 'axios'\n\nimport { usagerDao } from '@dugrema/millegrilles.reactjs'\n\nimport { extraireExtensionsMillegrille } from '@dugrema/millegrilles.utiljs/src/forgecommon'\nimport { genererClePrivee, genererCsrNavigateur } from '@dugrema/millegrilles.utiljs/src/certificats'\n\nimport { pki as forgePki } from '@dugrema/node-forge'\n\nexport async function sauvegarderCertificatPem(usager, chainePem, dataAdditionnel) {\n    dataAdditionnel = dataAdditionnel || {}\n\n    const certForge = forgePki.certificateFromPem(chainePem[0])  // Validation simple, format correct\n    const nomUsager = certForge.subject.getField('CN').value\n    // const validityNotAfter = certForge.validity.notAfter.getTime()\n    // console.debug(\"Sauvegarde du nouveau cerfificat de navigateur usager %s, expiration %O\", nomUsager, validityNotAfter)\n  \n    if(nomUsager !== usager) throw new Error(`Certificat pour le mauvais usager : ${nomUsager} !== ${usager}`)\n  \n    const copieChainePem = [...chainePem]\n    if(copieChainePem.length < 2) throw new Error(`Certificat recu n'a pas intermediaire/CA (len=${chainePem.length}): ${chainePem.join('')}`)\n\n    const params = {...dataAdditionnel, requete: null}\n\n    if(copieChainePem.length === 3) {\n        params.ca = copieChainePem.pop()\n    }\n    params.certificat = copieChainePem\n\n    await usagerDao.updateUsager(usager, params)\n}\n\nexport function getUserIdFromCertificat(certificat) {\n    let certForge = certificat\n    if(typeof(certificat) === 'string') {\n        certForge = forgePki.certificateFromPem(certificat)\n    }\n    const extensions = extraireExtensionsMillegrille(certForge)\n    const userId = extensions.userId\n    return userId\n}\n\nexport async function genererCle(nomUsager) {\n    // Generer nouveau keypair et stocker\n    const cles = await genererClePrivee()\n\n    // Extraire cles, generer CSR du navigateur\n    // const clePubliqueBytes = String.fromCharCode.apply(null, multibase.encode('base64', cles.publicKey.publicKeyBytes))\n    const fingerprintPublicKey = Buffer.from(cles.publicKey.publicKeyBytes).toString('hex')\n    // const fingerprintPublicKey = await hachage.hacher(publicKeyBytes, {hashingCode: 'blake2s-256', encoding: 'base58btc'})\n    console.debug(\"Fingerprint publickey : %O \\n(bytes : %O)\", fingerprintPublicKey, cles.publicKey.publicKeyBytes)\n\n    // const clePubliqueBytes = base58btc.encode(cles.publicKey.publicKeyBytes)\n    const csrNavigateur = await genererCsrNavigateur(nomUsager, cles.pem)\n\n    return {\n        fingerprint_pk: fingerprintPublicKey, \n        csr: csrNavigateur,\n        clePriveePem: cles.pem,\n    }\n}\n\n// Initialiser le compte de l'usager\nexport async function initialiserCompteUsager(nomUsager, opts) {\n    if(!opts) opts = {}\n  \n    if( ! nomUsager ) throw new Error(\"Usager null\")\n  \n    let usager = await usagerDao.getUsager(nomUsager)\n    const certificat = usager?usager.certificat:null\n    let genererCsr = false\n  \n    // console.debug(\"initialiserNavigateur Information usager initiale : %O\", usager)\n  \n    if( !usager ) {\n        // console.debug(\"Nouvel usager, initialiser compte et creer CSR %s\", nomUsager)\n        genererCsr = true\n    } else if( opts.regenerer === true ) {\n        // console.debug(\"Force generer un nouveau certificat\")\n        genererCsr = true\n    } else if(!certificat && !usager.requete) {\n        // console.debug(\"Certificat/CSR absent, generer nouveau certificat\")\n        genererCsr = true\n    } else if(certificat) {\n        // Verifier la validite du certificat\n        const {certificatValide, canRenew} = verifierDateRenouvellementCertificat(certificat) \n        if(!certificatValide) {\n            // Certificat expire. Retirer certificat/cle du compte\n            await usagerDao.updateUsager(nomUsager, {nomUsager, certificat: null, clePriveePem: null, fingerprintPk: null})\n            usager.certificat = null\n            usager.clePriveePem = null\n        }\n        if( canRenew || !certificatValide ) {\n            // Generer nouveau certificat\n            console.warn(\"Certificat invalide ou date de renouvellement atteinte\")\n            genererCsr = true\n        }\n    }\n  \n    if(genererCsr) {\n        const nouvellesCles = await genererCle(nomUsager)\n        const {csr, clePriveePem, fingerprint_pk} = nouvellesCles\n        const requete = {csr, clePriveePem, fingerprintPk: fingerprint_pk}\n        await usagerDao.updateUsager(nomUsager, {nomUsager, requete})\n        usager = {...usager, nomUsager, requete}\n    }\n  \n    // console.debug(\"Compte usager : %O\", usager)\n    return usager\n}\n\nfunction verifierDateRenouvellementCertificat(certificat) {\n    // Verifier la validite du certificat\n    const certForge = forgePki.certificateFromPem(certificat.join(''))\n    \n    const validityNotAfter = certForge.validity.notAfter.getTime(),\n            validityNotBefore = certForge.validity.notBefore.getTime()\n    const certificatValide = new Date().getTime() < validityNotAfter\n\n    // Calculer 2/3 de la duree pour trigger de renouvellement\n    const validityRenew = (validityNotAfter - validityNotBefore) / 3.0 * 2.0 + validityNotBefore\n    const canRenew = new Date().getTime() > validityRenew\n\n    // console.debug(\n    //     \"Certificat valide presentement : %s, epoch can renew? (%s) : %s (%s)\",\n    //     certificatValide, canRenew, validityRenew, new Date(validityRenew)\n    // )\n\n    return {certificatValide, canRenew}\n}\n\nexport function getNomUsagerCsr(csrPem) {\n    try {\n        // console.debug(\"Charger pem csr : %O\", csrPem)\n        const csrForge = forgePki.certificationRequestFromPem(csrPem)\n        // console.debug(\"CSR Forge : %O\", csrForge)\n\n        const cn = csrForge.subject.getField('CN').value\n        // console.debug(\"Common name : %O\", cn)\n\n        return cn\n    } catch(err) {\n        console.warn(\"Erreur chargement CSR : %O\", err)\n        return null\n    }\n}\n\nexport async function preparerUsager(workers, nomUsager, erreurCb, opts) {\n    opts = opts || {}\n    const genererChallenge = opts.genererChallenge\n    const connexion = null  // workers.connexion\n    console.debug(\"comptesUtil.preparerUsager Suivant avec usager %s\", nomUsager)\n    \n    // Verifier etat du compte local. Creer ou regenerer certificat (si absent ou expire).\n    let usagerLocal = await initialiserCompteUsager(nomUsager) \n\n    let fingerprintNouveau = null,\n        fingerprintCourant = null\n    if(usagerLocal) {\n        fingerprintCourant = usagerLocal.fingerprintPk\n        if(usagerLocal.requete) {\n            fingerprintNouveau = usagerLocal.requete.fingerprintPk\n        }\n    }\n\n    const etatUsagerWebAuth = await chargerUsager(\n        nomUsager, fingerprintNouveau, fingerprintCourant, \n        {genererChallenge}\n    )\n    // console.debug(\"Etat usager backend : %O\", etatUsagerBackend)\n\n    const infoUsager = etatUsagerWebAuth.infoUsager || {}\n    const certificat = infoUsager.certificat\n    if(certificat) {\n        // Mettre a jour le certificat\n        const usager = await usagerDao.getUsager(nomUsager)\n        const requete = usager.requete\n        if(requete) {\n            const { clePriveePem, fingerprintPk } = requete\n            // Extraire le certificat\n            const dataAdditionnel = {clePriveePem, fingerprintPk}\n            await sauvegarderCertificatPem(nomUsager, certificat, dataAdditionnel)\n        }\n    }\n\n    return etatUsagerWebAuth\n    // await setEtatUsagerBackend(etatUsagerBackend)\n    // await setUsagerDbLocal(await usagerDao.getUsager(nomUsager))\n}\n\n// export async function chargerUsager(connexion, nomUsager, fingerprintPk, fingerprintCourant, opts) {\n//     opts = opts || {}\n//     const hostname = window.location.hostname\n//     opts = {hostname, ...opts, fingerprintPk, fingerprintCourant}\n//     const infoUsager = await connexion.getInfoUsager(nomUsager, opts)\n//     return {nomUsager, infoUsager, authentifie: false}\n// }\n\nexport async function chargerUsager(nomUsager, fingerprintPk, fingerprintCourant, opts) {\n    opts = opts || {}\n    const hostname = window.location.hostname\n    const data = {\n        nomUsager, hostname, \n        ...opts, \n        fingerprintPkNouveau: fingerprintPk, fingerprintPkCourant: fingerprintCourant\n    }\n    const reponse = await axios({method: 'POST', url: '/auth/get_usager', data, timeout: 20_000})\n    const reponseEnveloppe = reponse.data\n    const infoUsager = JSON.parse(reponseEnveloppe.contenu)\n    console.debug(\"chargerUsager Reponse \", infoUsager)\n    const authentifie = infoUsager?infoUsager.auth:false\n    return {nomUsager, infoUsager, authentifie}\n}\n\n/** \n * Supprime toutes les idb databases autre que celles de maitre des comptes, vide les cles, et autre storage.\n */\nconst DATABASES = ['collections', 'documents', 'messagerie']\nconst CACHE_STORAGE_NAMES = ['fichiersDechiffresTmp']\nexport async function cleanupNavigateur() {\n    if('indexedDB' in window) {\n        let databases = DATABASES\n        if('databases' in window.indexedDB) {\n            console.debug(\"Supporte indexedDB.databases()\")\n            databases = await window.indexedDB.databases()\n            console.log(databases)\n        }\n\n        // Supprimer databases\n        const promisesDelete = []\n        for (const databaseName of databases) {\n            if(databaseName === 'millegrilles') continue  // Skip DB millegrilles\n            console.debug(\"Supprimer database %s\", databaseName)\n            const promise = new Promise((resolve, reject)=>{\n                const request = window.indexedDB.deleteDatabase(databaseName)\n                request.onblocked = e=>{\n                    console.warn(\"delete blocked sur database %s : %O\", databaseName, e)\n                }\n                request.onerror = err => {\n                    console.warn(\"Erreur suppression database %s : %O\", databaseName, err)\n                    resolve()\n                }\n                request.onsuccess = () => {\n                    console.debug(\"Database %s supprimee\", databaseName)\n                    resolve()\n                }\n            })\n            promisesDelete.push(promise)\n        }\n\n        // Clear les cles dechiffrees\n        promisesDelete.push(usagerDao.clearClesDechiffrees())\n\n        // Supprimer cache storage\n        if(caches) {\n            const cacheStorage = caches\n            for (const cacheName of CACHE_STORAGE_NAMES) {\n                promisesDelete.push( cacheStorage.delete(cacheName) )\n            }\n        }\n\n        await Promise.all(promisesDelete)\n\n    } else {\n        console.debug(\"IDB non supporte\")\n    }\n}\n","import {\n    hacher, verifierHachage, \n    Hacheur, VerificateurHachage, \n    calculerDigest,\n    hacherCertificat, comparerArraybuffers,\n    setHacheurs,\n} from '@dugrema/millegrilles.utiljs/src/hachage'\nimport { createSHA256, createSHA512, createBLAKE2b, createBLAKE2s } from 'hash-wasm'\n\n// Injecte les methodes de hachage natives avec setHacheurs pour la librairie utiljs\n\nconst constructeur = async methode => {\n    const hacheur = await methode()\n    return {\n        update: buffer => hacheur.update(buffer),\n        finalize: () => hacheur.digest('binary'),\n        digest: async buffer => { await hacheur.update(buffer); return await hacheur.digest('binary') }\n    }\n}\n\n// Utilise subtle pour digest() one shot et WASM pour blocks avec update/finalize\n// const constructeurSubtle = async (methode, algo) => {\n//     console.debug(\"Constructeur subtle methode %O, algo %O\", methode, algo)\n//     const hacheur = await methode()\n//     console.debug(\"window %O, self %O\", window, self)\n//     let refHandle = window || self\n//     return {\n//         update: buffer => hacheur.update(buffer),\n//         finalize: () => hacheur.digest('binary'),\n//         digest: async buffer => refHandle.crypto.subtle.digest(algo, buffer)\n//     }\n// }\n\nconst hacheurs = {\n    // hash-wasm\n    'sha256': () => constructeur(createSHA256),\n    'sha2-256': () => constructeur(createSHA256),\n    'sha512': () => constructeur(createSHA512),\n    'sha2-512': () => constructeur(createSHA512),\n    'blake2s256': () => constructeur(createBLAKE2s),\n    'blake2s-256': () => constructeur(createBLAKE2s),\n    'blake2b512': () => constructeur(createBLAKE2b),\n    'blake2b-512': () => constructeur(createBLAKE2b),\n}\n\n// console.debug(\"Set hacheurs : %O\", hacheurs)\nsetHacheurs(hacheurs)\n\n// export default {\n//     hacher, verifierHachage, \n//     Hacheur, VerificateurHachage, \n//     calculerDigest,\n//     hacherCertificat, comparerArraybuffers,\n//     setHacheurs, \n//     hacheurs,\n// }\n\nexport { \n    hacher, verifierHachage, \n    Hacheur, VerificateurHachage, \n    calculerDigest,\n    hacherCertificat, comparerArraybuffers,\n    setHacheurs, \n    hacheurs,\n}"],"names":["repondreRegistrationChallenge","nomUsager","challengeWebauthn","opts","DEBUG","console","debug","challenge","Buffer","from","attestation","userId","user","id","publicKey","name","displayName","navigator","credentials","create","newCredential","credentialResponse","response","jsonData","base64url","clientDataJSON","attestationObject","Uint8Array","data","type","BoutonAjouterWebauthn","props","variant","className","resetMethodes","confirmationCb","erreurCb","connexion","useWorkers","usagerDb","useUsagerDb","fingerprintPkCourant","fingerprintPk","useState","setChallenge","resultat","setResultat","onClickCb","useCallback","event","preventDefault","stopPropagation","ajouterMethode","then","catch","err","useEffect","getChallengeAjouter","BoutonActif","etat","onClick","disabled","children","BoutonAuthentifierWebauthn","dureeSession","onError","onSuccess","workers","requeteCsr","requete","reponseChallengeAuthentifier","setReponseChallengeAuthentifier","attente","setAttente","erreur","setErreur","handlerErreur","message","authentifierCb","demandeCertificat","authentifier","reponse","finally","preparerAuthentification","etatBouton","BoutonMajCertificatWebauthn","usager","csrChallenge","setCsrChallenge","majCertificatCb","challengeReference","majCertificat","error","hostname","window","location","genererChallenge","webauthnAuthentication","authentication_challenge","Button","preparerNouveauCertificat","genererCle","cleCsr","getInfoUsager","infoUsager","challengeWebAuthn","signerDemandeAuthentification","demandeSignee","commande","clientAssertionResponse","webauthn","signerCompteUsager","webauthnRegistration","registration_challenge","params","reponseChallenge","reset_cles","repondreChallengeRegistrationWebauthn","resultatAjout","ok","Error","allowCredentials","map","cred","idBytes","csr","date","Math","floor","Date","getTime","activationTierce","hacherMessage","bytesOnly","hashingCode","hachageDemandeCert","challengeMaj","set","axios","post","resultatAuthentification","contenu","JSON","parse","Number","parseInt","get","publicKeyCredentialSignee","reponseSignee","reponseSerialisable","id64","rawId","authenticatorData","signature","userHandle","sauvegarderCertificatPem","chainePem","dataAdditionnel","certForge","forgePki","certificateFromPem","subject","getField","value","copieChainePem","length","join","ca","pop","certificat","usagerDao","updateUsager","getUserIdFromCertificat","extraireExtensionsMillegrille","genererClePrivee","cles","fingerprintPublicKey","publicKeyBytes","toString","genererCsrNavigateur","pem","csrNavigateur","fingerprint_pk","clePriveePem","initialiserCompteUsager","getUsager","genererCsr","regenerer","verifierDateRenouvellementCertificat","certificatValide","canRenew","warn","nouvellesCles","validityNotAfter","validity","notAfter","validityNotBefore","notBefore","validityRenew","chargerUsager","fingerprintCourant","fingerprintPkNouveau","method","url","timeout","reponseEnveloppe","authentifie","auth","DATABASES","CACHE_STORAGE_NAMES","cleanupNavigateur","databases","indexedDB","log","promisesDelete","databaseName","promise","Promise","resolve","reject","request","deleteDatabase","onblocked","e","onerror","onsuccess","push","clearClesDechiffrees","caches","cacheStorage","cacheName","delete","all","constructeur","methode","hacheur","update","buffer","finalize","digest","hacheurs","createSHA256","createSHA512","createBLAKE2s","createBLAKE2b","setHacheurs"],"sourceRoot":""}